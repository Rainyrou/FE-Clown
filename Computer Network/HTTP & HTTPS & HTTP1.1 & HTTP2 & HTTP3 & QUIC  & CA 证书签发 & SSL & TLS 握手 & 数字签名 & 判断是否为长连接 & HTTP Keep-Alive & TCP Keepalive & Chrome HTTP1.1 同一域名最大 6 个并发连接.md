HTTP：

1. 简单：报文格式为 header + body ，头部为 key + value
2. 易于扩展：请求方法、URI/URL、状态码和头部字段等允许自定义扩展，此外由于 HTTP 在应用层，其下层可变化如 HTTPS 在 HTTP 与 TCP 层间增加 SSL/TLS 安全传输层，HTTP/3 将 TCP 层换为基于 UDP 的 QUIC
3. 跨平台
4. 无状态：HTTP 无状态，服务端无需记录其状态信息，但每次进行有关联性的操作时均需认证用户身份
5. 明文传输：通过 F12 控制台和 Wireshark 抓包直接查看传输过程中的信息，便于调试，但也相当于信息裸奔
6. 未验证接收方身份且无法验证报文的完整性

HTTPS：

1. HTTP 端口号为 80，HTTPS 端口号为 443
2. HTTP 在 TCP 三次握手后即可建立连接，而 HTTPS 在 TCP 三次握手后还需进行 SSL/TLS 握手方可建立连接
3. HTTPS 采用对称加密和非对称加密的混合加密方式，在建立连接前以非对称加密的方式交换密钥，在通信过程中以对称加密的方式加密明文。对称加密只使用一个密钥，其基于置换原理，通过多轮转换将明文转换为密文，速度快但安全性较低，而非对称加密的公钥公开，私钥保密，速度慢但安全性较高，其基于数学难题如大数因子分解（RSA 算法）、离散对数（ElGamal 算法）和椭圆曲线对数（ECC 算法）加密密钥，仅根据公钥难以推导密钥
4. 服务端公钥置于数字证书以验证接收方身份
5. HTTPS 以摘要算法验证报文的完整性

HTTP1.1：

1. 长连接：HTTP1.1 采用长连接的方式，通信双方持久连接除非一方主动断开
2. 管道传输：在同一 TCP 连接里并发多个 HTTP1.1 请求，发送一个请求后，无需等待其返回即可发送下一请求

HTTP2：

1. 头部压缩：HPACK 压缩算法压缩重复头部
2. 二进制格式：头信息帧和数据体帧，接收到报文后直接解析，无需将明文转换为二进制
3. 数据流：标记数据包，无需依照顺序发送，指定数据流优先级，允许接收方控制发送方的数据接收量，避免接收方的缓冲区溢出
4. 多路复用：通过一个 TCP 连接实现多个请求和响应的并行传输，每个请求和响应对应一个流，二进制分帧层将一个 TCP 连接中的多个请求拆分为小帧并通过为每个请求/响应分配唯一流 ID，服务端接收所有请求的帧，根据流 ID 将帧分发至对应的流处理器，并行处理多个请求，通过同一 TCP 连接交错返回响应，客户端根据流 ID 将帧重组为完整的响应，分发到对应的请求回调
5. 服务端主动推送

HTTP3/QUIC：

1. 头部压缩：QPACK 压缩算法压缩重复头部

![[Pasted image 20240424172105.png]]

2. QUIC 基于 UDP 实现类 TCP 的可靠性传输，以连接 ID  替代 TCP 四元组作为连接标识，0-RTT 恢复实现移动设备无缝切换网络；0/1-RTT 握手（首次连接 1-RTT，复用连接 0-RTT）合并 TCP 握手和 SSL/TLS 过程，首次连接客户端发送 ClientHello 给服务端，其包含客户端支持的 TLS 版本、加密组合和连接 ID 等，服务端返回 ServerHello，其包含客户端支持的 TLS 版本、加密组合和确认连接 ID 等，同时完成 SSL/TLS 握手，建立连接，复用连接客户端直接使用缓存的 Server Config 跳过握手过程直接建立连接；QUIC 的流在应用层提供可靠性，在传输层实现并行传输，基于 QUIC 流的多路复用，在一个 QUIC 连接内部建立多个逻辑流，流间互相独立，若某个流的数据包丢失，只阻塞该流传输而不影响其他流，突破 HTTP2 TCP 单一字节流队头阻塞的限制（单个 TCP 数据包丢失阻塞所有 HTTP2 流）；实现自身的流量控制和拥塞控制机制，将其于操作系统内核中解放出来，基于前向纠错的优化策略和基于包号的确认机制，消除 TCP 区分新旧数据包的歧义，提升丢包恢复速度

CA 证书签发：

1. 密钥对生成与 CSR 构建：运营者于服务端生成一对非对称密钥私钥和公钥，其将公钥、服务端域名和身份信息等封装为 CSR 并通过私钥对 CSR 签名
2. 身份验证与授权：CA 验证申请者的真实身份，DV 域名验证 -> 确认申请者对域名的控制权，OV 组织验证 -> 确认申请者对域名控制权 + 组织身份真实性，EV 扩展验证 -> 确认最高级别身份 + 组织身份 + 域名归属 + 法律资质
3. CSR 验证：通过 CSR 的公钥解密申请者的签名，获取哈希值，同时对 CSR 的公钥、服务端域名和身份信息重新计算哈希，比较两者确保其未被篡改
4. 证书生成与 CA 签名：将申请者信息 + 公钥绑定并通过 CA 私钥签名，生成可信任的数字证书
5. 分发证书证书链的构建：证书通过中间 CA签发，返回给申请者，申请人将证书与私钥一同部署于服务端，服务端进行 TLS 握手时，将证书发送给客户端，用于证明身份；用户证书无法直接信任，需通过证书链（用户证书 → 中间 CA 证书 → 根 CA 证书）追溯至根 CA 证书，客户端在验证证书时，沿着证书链向上逐步验证至根 CA 证书，才算验证成功

SSL/TLS 握手：

1. 客户端发送 ClientHello 给服务端，其包含客户端支持的 TLS 版本，加密组合（格式：密钥交换算法-对称加密算法-消息认证码算法）及生成的随机数 Client Random
2. 服务端返回 ServerHello（选择的 TLS 版本、加密组合及生成的随机数 Server Random）、Certificate（服务端域名、CA 签名、公钥、证书有效期和证书链）、ServerKeyExchange（可选）和 CertificateRequest（可选，双向认证）
3. 客户端验证服务端 Certificate，生成 Pre-Master Secret，发送 ClientKeyExchange（加密后的 Pre-Master Secret）、ChangeCipherSpec（切换加密模式）、Finished（验证握手完整性）、Certificate（可选，与服务端 CertificateRequest 匹配，双向认证）和 CertificateVerify（可选，双向认证）
4. 服务端解密获取 Pre-Master Secret，验证客户端 Finished 消息及其身份（可选，双向认证），发送 ChangeCipherSpec（切换加密模式）和 Finished（验证握手完整性）
5. 客户端接收、解密并验证服务端  Finished  消息，后续双方通过协商的加密算法通信

数字签名：

1. 发送方 A 生成消息哈希，以其私钥加密生成数字签名
2. 发送方 A 发送原始消息和数字签名到接收方 B
3. 接收方 B 接收到消息后，通过发送方 A 的公钥解密数字签名，获取哈希值 1
4. 接收方 B 计算接收到的消息之哈希，获取哈希值 2
5. 若哈希值 1 等于哈希值 2，则数字签名验证成功，消息来源于发送方 A 且未被篡改

判断是否为长连接：

- HTTP 1.0 在请求和响应头部指定 `Connection: keep-alive`
- HTTP 1.1 以上默认为长连接

HTTP Keep-Alive：HTTP1.1 采用长连接的方式，通信双方持久连接除非一方主动断开，HTTP 请求头部字段 `Connection: keep-alive`

TCP Keepalive：若在指定的时间内，连接上无任何数据传输，发送方定期自动发送 Keepalive 探针检测接收方是否响应以确认连接的有效性，若在指定时间内未接收到响应，则 TCP 自动关闭连接

HTTP1.1 采用长连接的方式，通信双方持久连接除非一方主动断开，在同一 TCP 连接里并发多个 HTTP1.1 请求，发送一个请求后，无需等待其返回即可发送下一请求，而 Chrome 默认为同一域名维护一个连接池（最多包含 6 个 TCP 连接），由于各个 TCP 连接一次仅能处理一个请求，因此 6 个连接最多同时处理 6 个请求，若超过限制则后续请求置于任务队列等待空闲时处理
