HTTP：

1. 简单：报文格式为 header + body ，头部为 key + value
2. 易于扩展：请求方法、URI/URL、状态码和头部字段等允许自定义扩展，此外由于 HTTP 在应用层，其下层可变化如 HTTPS 在 HTTP 与 TCP 层间增加 SSL/TLS 安全传输层，HTTP/3 将 TCP 层换为基于 UDP 的 QUIC
3. 跨平台
4. 无状态：HTTP 无状态，服务端无需记录其状态信息，但每次进行有关联性的操作时均需认证用户身份
5. 明文传输：通过 F12 控制台和 Wireshark 抓包直接查看传输过程中的信息，便于调试，但也相当于信息裸奔
6. 未验证接收方身份且无法验证报文的完整性

HTTPS：

1. HTTP 端口号为 80，HTTPS 端口号为 443
2. HTTP 在 TCP 三次握手后即可建立连接，而 HTTPS 在 TCP 三次握手后还需进行 SSL/TLS 握手方可建立连接
3. HTTPS 采用对称加密和非对称加密的混合加密方式，在建立连接前以非对称加密的方式交换密钥，在通信过程中以对称加密的方式加密明文。对称加密只使用一个密钥，其基于置换原理，通过多轮转换将明文转换为密文，速度快但安全性较低，而非对称加密的公钥公开，私钥保密，速度慢但安全性较高，其基于数学难题如大数因子分解（RSA 算法）、离散对数（ElGamal 算法）和椭圆曲线对数（ECC 算法）加密密钥，仅根据公钥难以推导密钥
4. 服务端公钥置于数字证书以验证接收方身份
5. HTTPS 以摘要算法验证报文的完整性

HTTP1.1：

1. 长连接：HTTP1.1 采用长连接的方式，通信双方持久连接除非一方主动关闭连接
2. 管道传输：在同一 TCP 连接里并发多个 HTTP1.1 请求，发送一个请求后，无需等待其返回即可发送下一请求

HTTP2：

1. 头部压缩：HPACK 压缩算法压缩重复头部
2. 二进制格式：头信息帧和数据体帧，接收到报文后直接解析，无需将明文转换为二进制
3. 数据流：标记数据包，无需依照顺序发送，指定数据流优先级，允许接收方控制发送方的数据接收量，避免接收方的缓冲区溢出
4. 多路复用：通过一个 TCP 连接实现多个请求和响应的并行传输，每个请求和响应对应一个流，二进制分帧层将一个 TCP 连接中的多个请求拆分为小帧并通过为每个请求/响应分配唯一流 ID，服务端接收所有请求的帧，根据流 ID 将帧分发至对应的流处理器，并行处理多个请求，通过同一 TCP 连接交错返回响应，客户端根据流 ID 将帧重组为完整的响应，分发到对应的请求回调
5. 服务端主动推送

HTTP3/QUIC：

1. 头部压缩：QPACK 压缩算法压缩重复头部

![[Pasted image 20240424172105.png]]

2. QUIC 基于 UDP 实现类 TCP 的可靠性传输，以连接 ID  替代 TCP 四元组作为连接标识，0-RTT 恢复实现移动设备无缝切换网络；0/1-RTT 握手（首次连接 1-RTT，复用连接 0-RTT）合并 TCP 握手和 SSL/TLS 过程，首次连接客户端发送 ClientHello 给服务端，其包含客户端支持的 TLS 版本、加密组合和连接 ID 等，服务端返回 ServerHello，其包含客户端支持的 TLS 版本、加密组合和确认连接 ID 等，同时完成 SSL/TLS 握手，建立连接，复用连接客户端直接使用缓存的 Server Config 跳过握手过程直接建立连接；QUIC 的流在应用层提供可靠性，在传输层实现并行传输，基于 QUIC 流的多路复用，在一个 QUIC 连接内部建立多个逻辑流，流间互相独立，若某个流的数据包丢失，只阻塞该流传输而不影响其他流，突破 HTTP2 TCP 单一字节流队头阻塞的限制（单个 TCP 数据包丢失阻塞所有 HTTP2 流）；实现自身的流量控制和拥塞控制机制，将其于操作系统内核中解放出来，基于前向纠错的优化策略和基于包号的确认机制，消除 TCP 区分新旧数据包的歧义，提升丢包恢复速度

判断是否为长连接：HTTP 1.0 在请求响应头部字段 `Connection: keep-alive` + HTTP 1.1/HTTP2/HTTP3

HTTP Keep-Alive：采用长连接的方式，通信双方持久连接除非一方主动关闭连接

TCP Keepalive：若在指定时间内连接上无数据传输，发送方定期发送 Keepalive 探针检测连接有效性，若在指定时间内未接收到有效响应，则自动关闭连接

HTTP 各版本 10 个资源的 TCP 连接数与总耗时：

* 单个资源传输 RTT=100ms
* HTTP1.0：TCP 连接数 -> 10 个 + 总耗时 -> 200ms（TCP 握手 1RTT + 资源并行传输 1RTT）
* HTTP1.1：TCP 连接数 -> 1 个 + 总耗时 -> 1100ms（ TCP 握手 1RTT + 资源串行传输 10RTT）
* HTTP2：TCP 连接数 -> 10 个 + 总耗时 -> 200ms（TCP 握手 1RTT + 资源并行传输 1RTT）
* HTTP3：TCP 连接数 -> 0 个 + 总耗时 -> 200ms（QUIC 首次握手 1RTT + 资源并行传输 1RTT）

Chrome 为同一域名维护连接池（最多 6 个 TCP 连接），而 TCP 连接一次处理单个请求，若超过6个则后续请求置于任务队列等待空闲时处理