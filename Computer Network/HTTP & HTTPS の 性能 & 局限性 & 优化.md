#### HTTP

##### 性能

简单、灵活和易于扩展、应用广泛和跨平台

1. 简单

HTTP 的报文格式是 header + body ，头部信息是 key-value 的形式

2. 灵活和易于扩展

HTTP 的请求方法、URI/URL、状态码、头部字段等构成都没有固定死，允许开发人员自定义和扩展

同时由于 HTTP 是工作在应用层 ( OSI 第七层) ，它的下层可以随意变化。HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCP 层换成了基于 UDP 的 QUIC

3. 应用广泛和跨平台

##### 双刃剑

1. 无状态

HTTP 无状态，因此服务器无需记录其状态信息，这能减轻服务器的负担，把更多 CPU 和内存用来对外提供服务

但 HTTP 无状态，服务器在完成有关联性的操作时会非常繁琐，每操作一次，都要认证用户身份，解决方案有使用 Cookie 技术

2. 明文传输

我们可以通过浏览器 F12 控制台或 Wireshark 抓包直接用肉眼查看传输过程中的信息，这方便调试。但这也相当于信息裸奔，在传输过程中，信息毫无隐私可言，很轻易就能被窃取

##### 局限性

- 明文传输，内容可能会被窃听
- 不验证通信方身份，可能遭遇伪装
- 无法验证报文的完整性，内容可能已遭篡改

#### HTTPS

##### 性能

1. HTTPS 在 HTTP 和 TCP 之间加入了 SSL/TLS 安全传输层，使得报文能够加密传输，解决 HTTP 不安全的缺陷

- 采用混合加密的方式实现信息加密，交互信息无法被窃取

HTTPS 采用对称加密和非对称加密结合的混合加密方式：在通信建立前采用非对称加密的方式交换会话秘钥，在通信过程中采用对称加密的方式加密明文数据

采用混合加密的原因：对称加密只使用一个密钥，速度快，但密钥必须保密，无法做到安全的密销交换。非对称加密使用公钥和私钥，速度慢，公钥可以任意分发而私钥必须保密，解决了密钥交换问题

- 采用摘要算法的方式实现报文的完整性，校验数据机制使通信内容无法被篡改，即便被篡改了信息也无法正常显示

- 将服务器公钥放入到数字证书中，解决了冒充的风险

客户端先向服务器索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。这需要借助 CA，将服务器公钥放在数字证书中，只要证书可信，公钥就是可信的

2. HTTP 连接建立相对简单，TCP 三次握手后便可进行 HTTP 报文传输。而 HTTPS 在 TCP 三次握手
   后，还需进行 SSL/TLS 的握手过程，才可进行加密报文传输

3. HITP 的端口号是 80，HTTPS 的端口号是 443

##### 性能损耗

HTTP 升级为 HTTPS 提高安全性的同时，也带来了性能损耗。HTTPS 相比 HTTP 多一个 TLS 握手过程，这个过程至多消耗 2 RTT，握手后的对称加密报文传输也会产生性能损耗

现在主流的对称加密算法 AES、ChaCha20 都有较好性能，且一些 CPU 厂商针对它们还做了硬件级别的优化，因此后者的性能消耗可以忽略不计

而前者不仅增加了网络延时（至多消耗 2 RTT），握手过程还会产生其他的性能损耗：

- 对于 ECDHE 密钥协商算法，握手过程中客户端和服务器都需要临时生成椭圆曲线公私钥
- 客户端验证证书时会访问 CA 获取 CRL 或 OCSP，以验证服务器的证书是否有效
- 双方计算 Pre-Master，即对称加密密钥

##### 优化

###### 硬件优化

氪金

HTTPS 是计算密集型，而不是 I/O 密集型，钱应该花在 CPU 上。CPU 可以提高计算性能，因为 HTTPS 连接中有大量需要计算密钥的过程，这样可以加速 TLS 握手

###### 软件优化

软件升级到最新版本

###### 协议优化

协议优化就是对密钥交换过程进行优化

1. 密钥交换算法优化

尽量选用 ECDHE 密钥交换算法替换 RSA，因为该算法支持 False Start ，客户端可以在 TLS 第 3 次握手后，第 4 次握手前，发送加密数据，将 TLS 握手由 2 RTT 减少至 1 RTT，且具备前向安全性。ECDHE 算法是基于椭圆曲线实现的，尽量选择 x25519 曲线

2. TLS 升级

直接把 TLS 1.2 升级成 TLS 1.3，TLS 1.3 大幅简化握手过程，完成 TLS 握手只要 1 RTT，且提高了安全性：

- 对于密钥交换算法，TLS 1.3 废除了不支持前向安全性的 RSA 和 DH 算法，只支持 ECDHE 算法
- 对于对称加密和签名算法，只支持目前最安全的几个密码套件

###### 证书优化

1. 证书传输优化

选择 ECDSA 证书，而非 RSA 证书，，因为在相同安全强度下，ECC 密钥长度比 RSA 短的多，这样能减少证书大小，节约带宽

2. 证书验证优化

证书链逐级验证，需用 CA 公钥解密证书，以及用签名算法验证证书的完整性。客户端有时还会再去访问 CA，下载 CRL 或者 OCSP 数据，以此确认证书的有效性。这个访问过程是 HTTP 访问，又会产生网络通信开销，如 DNS 查询、建立连接、收发数据

OCSP Stapling：服务器向 CA 周期性地查询证书状态，获取一个带有时间戳和签名的响应结果并缓存它

当客户端发起请求时，服务器会在 TLS 握手过程中把这个响应结果返回给客户端。由于有签名的存在，服务器无法篡改，客户端就能得知证书是否已被吊销，这样客户端就无需再去查询

###### 会话复用

TLS 握手是为了协商出会话密钥，即对称加密密钥

会话复用 (TLS session resumption)：把首次 TLS 握手得到的对称加密密钥缓存起来，待下次需要建立 HTTPS 连接时，直接复用

1. Session ID

Session ID 的基本原理：客户端和服务器首次 TLS 握手连接后，双方在内存缓存会话密钥，并用唯一 Session ID 来标识，Session ID 和会话密钥相当于 key-value 的关系

当客户端再次连接时，hello 消息里会带上 Session ID，服务器收到后就会从内存里查找，如果找到，就直接用该会话密钥恢复会话状态，跳过其余过程。为了安全性，内存中的会话密钥会定期失效

但它有局限性：服务器必须缓存每个客户端的会话密钥，随着客户端增多，服务器的内存压力也会增大。再者，现在网站服务一般是由多台服务器通过负载均衡提供服务的，客户端再次连接时不一定会命中上次访问过的服务器，于是还要走完整的 TLS 握手过程

2. Session Ticket

为解决 Session ID 的问题，Session Ticket 应运而生，服务器不再缓存每个客户端的会话密钥，而是将缓存的工作交由客户端，类似于 HTTP 的 Cookie

客户端与服务器首次建立连接时，服务器会加密会话密钥，作为 Ticket 发送给客户端，交由客户端缓存该 Ticket
客户端再次连接服务器时，客户端发送 Ticket，服务器解密后就可以获取上一次的会话密钥，然后验证有效期，如果没有问题就可以恢复会话，开始加密通信

对于集群服务器的话，要确保每台服务器加密会话密钥的密钥一致，这样客户端携带 Ticket 访问任意服务器时，都能恢复会话

然而，Session lD 和 Session Ticket 都不具备前向安全性，一旦加密会话密钥的密钥被破解或服务器泄漏会话密钥，所有的努力都将白费

3. Pre-shared Key

Session ID 和 Session Ticket 方式都需要在 1 RTT 才能恢复会话

而重连 TLS1.3 只需要 0 RTT，原理和 Ticket 类似，只不过在重连时，客户端会把 Ticket 和 HTTP 请求一同发送给服务端，这种方式叫 Pre-shared Key

然鹅，上述三者都难以应对重放攻击

应对重放攻击：给会话密钥设定一个合理的过期时间，且只针对安全的 HTTP 请求如 GET/HEAD 使用会话重用
