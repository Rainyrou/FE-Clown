1. 长连接：HTTP/1.0 每发起一个请求，均需 TCP 三次握手且是串行请求，导致 TCP 连接重复建立与断开。为解决上述问题，HTTP/1.1 使用长连接，任一方未明确断开连接，则保持连接状态，减少 TCP 连接重复建立与断开造成的开销，减轻服务端的压力
2. 管道传输：客户端在同一个 TCP 连接里可并发多个请求，发送第一个请求后，无需等待其返回即可发送第二个请求，减少整体的响应时间

###### 局限性

1. 请求/响应只压缩 Body，Header 未经压缩即发送，头部信息越多延迟越长，每次发送相同头部造成性能损耗。头部含多个固定字段如 Cookie、User Agent、Accept 等，它们加起来高达几百甚至上千字节，其次请求响应有大量重复字段，再者字段是 ASCII 编码的，解析效率低
2. 服务端依照请求顺序响应，若前面响应缓慢，后续有大量请求排队等待，造成队头阻塞，客户端一直请求不到数据
3. 无请求优先级控制
4. 只能从客户端发送请求，服务端被动响应

###### 解决方案

1. 使用 KeepAlive 将 HTTP/1.1 从短连接变为长链接
2. 避免发送 HTTP 请求，缓存重复 HTTP 请求于本地，key 为请求 URL，value 为响应，后续发送同一请求，在本地缓存通过 key 查找对应 value，若找到直接从本地缓存中获取
3. 减少重定向请求次数，重定向工作交由代理服务端完成，告诉其重定向规则，使用 301 和 308 而非 302 状态码告诉客户端可将重定向响应缓存于本地
4. 合并请求
5. 延迟发送请求，分页查询、按需获取
6. 减少响应数据大小，无损压缩



