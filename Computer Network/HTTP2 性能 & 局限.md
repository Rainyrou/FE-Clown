#### 性能

##### 1. 头部压缩

HTTP/2 未采用 gzip 压缩头部。当你同时发送多个请求，HTTP 会压缩重复的 Header，即 HPACK 算法

HPACK 算法：客户端和服务端同时维护一张头部信息表，所有字段都会存入这个表，生成索引号，之后不再发送相同字段，只发送索引号

HPACK 算法的组成：静态字典 + 动态字典 + Huffman 编码

用长度较小的索引号表示重复的字符串，再用 Hufman 编码压缩数据

###### 静态表编码

HITTP/2 为高频出现在头部的字段建立一张静态表。静态表共有 61 组，被写入 HTTP/2 框架里，不会发生变化

![[Pasted image 20231110200221.png]]

表中的 Index 表示 Key，Header Value 表示索引对应的 Value，Header Name 表示字段名。有些 Index 没有对应的 Header Value， 这是因为这些 Value 是变化的，它们需要经过 Huffman 编码后才会发送出去

###### 动态表编码

不在静态表内的头部字段就要自行构建动态表，它的 Index 从 62 开始，在解码时进行更新

比如，头部的 user-agent 字段数据有上百个字节，经过 Huffman 编码后进行第一次发送，客户端和服务器都会更新自己的动态表，添加一个新的 Index 62。下一次就无需重复发送该字段的数据，只发 1 字节的 Index 即可，因为客户端和服务器都可以根据自己的动态表获取字段数据

但动态表生效有一个前提：同一连接，传输完全相同的 HTTP 头部

随着同一 HTTP/2 连接上发送的报文增多，客户端和服务器的字典逐渐积累，理论上最终每个头部字段都会变成 1 字节的 Index，避免大量冗余数据的传输，节约带宽。但动态表越大，占用内存也越多，从而影响服务器性能，因此服务器都会提供类似 http2_max_requests 的配置，限制一个连接上传输的请求数量，请求数量达到上限后，就会关闭 HTTP/2 连接释放内存

##### 2. 二进制格式

HTTP/2 采用二进制格式，头信息帧和数据体帧。收到报文后无需再将明文转换为二进制，而是直接解析

![[Pasted image 20231109213558.png]]

##### 3. 数据流

![[Pasted image 20231110202059.png]]

HTTP/2 的数据包不按顺序发送，同一个连接里连续的数据包可能属于不同的响应。因此，需对数据包进行标记

每个请求或响应的所有数据包，称为一个 Stream，每个数据流都用一个唯一编号标记

HTTP 消息由多个 Frame 构成，1 个 Frame 由多个 TCP 报文构成

在 HTTP/2 连接上，不同 Stream 的帧可以乱序发送，即并发不同 Stream，因为每个头部会携带 Stream lD，因此接收端可以通过 Stream lD 有序组装成 HTTP 消息，但同一 Stream 内部的帧必须严格有序

客户端和服务器都可以建立 Stream，Stream ID 也有区别，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号

同一个连接中的 Stream ID 是不能复用的，只能按顺序递增。当 Stream ID 耗尽时，需要发一个控制帧 GOAWAY 来关闭 TCP 连接

HTTP/2 通过 Stream 实现的并发效果显著优于比 HTTP/1.1 通过 TCP 连接实现的，因为当 HTTP/2 实现 100 个并发 Stream 时，只需要建立 1 次 TCP 连接，而 HTTP/1.1 需要建立 100 个 TCP 连接，每个 TCP 连接都要经过 TCP 握手、慢启动以及 TLS 握手过程

客户端还可以指定数据流的优先级。优先级越高的请求，服务器越先响应

##### 4. 多路复用

HTTP/2 可以在一个连接中并发多个请求或响应，无需按照顺序一一对应，一定程度上避免了 HTTP/1.1 的队头阻塞的问题

##### 5. 服务端推送

HTTP/2 在一定程度上改变了传统的请求-响应模式，服务端不再被动响应，可以主动向客户端发起请求

比如，在浏览器请求 HTML 时，服务端提前把可能会用到的 JS 和 CSS 等静态资源主动发给客户端，减少延时等待，即服务器推送 (Server Push/Cache Push)

#### 局限性

##### 对头阻塞

HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用。多个 HTTP 请求复用一个 TCP 连接，下层的 TCP 协议不知道 HTTP 请求的数量。一旦发生丢包，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传

- HTTP/1.1 的 pipeline 传输中若有一个请求阻塞，那么队列后续的请求也一同阻塞

- HTTP/2 多个请求复用一个 TCP 连接，一旦发生丢包，所有的 HTTP 请求也一同阻塞

这都是基于 TCP 传输层的问题，因此 HTTP/3 把 HTTP 下层的 TCP 改成了 UDP

##### TCP 与 TLS 的握手时延迟

HTTP 经过 TCP 三次握手和 TLS1.2 四次握手（3RTT） 才能发出请求数据

由于拥塞控制的特性，刚建立连接的 TCP 会有一个慢启动的过程，会产生减速效果

##### 网络迁移时需要重新连接

TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，如果 IP 地址或者端口发生变动，TCP 和 TLS 都需要重新握手，这不利于移动设备切换网络
