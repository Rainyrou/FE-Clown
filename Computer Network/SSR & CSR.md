SSR 的特点是在服务器端合并所有的 DOM 和数据，生成完整的 HTML 字符串，并将其直接发送到客户端，客户端拿到的是完整的 URL，即页面在到达浏览器之前已经是完整的，因此可以直接被渲染，无需等待 JavaScript 下载和执行

##### 应用渲染静态页面

应用渲染静态页面可分为以下步骤：

1. 模板页面的渲染：使用模板引擎（如 EJS、Pug 等）或是 React/Vue 的 SSR 能力。以 React 为例，可通过 `react-dom/server` 的 `renderToString` 方法将 React 组件渲染成 HTML 字符串。编写对应页面的模板 -> 书写相关数据请求 -> 统一导出，渲染页面
2. 路由的匹配：根据不同的 URL 路径渲染不同的页面，服务器端根据请求的路径返回相应的 HTML 内容，在 React 的 SSR 应用中，可使用 `react-router` 的服务器端渲染能力来匹配路由
3. `header` 标签的修改：修改模板页面本身是无法直接去修改页面的 `header` 标签的，在服务器端渲染过程中，可以直接操作字符串来修改 `<head>` 标签内的内容，或使用专门的库如 React Helmet 来修改页面的头部信息

##### `renderToString`

在 SSR 中，`react-dom` 包提供的 `renderToString` 函数是核心技术之一。该函数能将 React 组件（模板）渲染成初始的 HTML 字符串，使得服务端能够发送该字符串到浏览器，浏览器随后展示这个 HTML 内容，而无需等待所有的 JavaScript 下载并执行，其有助于提高首屏加载速度，并对 SEO 非常友好，因为爬虫可以直接抓取并索引服务端返回的 HTML 内容

1. 虚拟 DOM 转换：`renderToString` 接收一个 React 元素，并将其转换为虚拟 DOM
2. 生成 HTML 字符串：经过转换后，`renderToString` 遍历虚拟 DOM 树，并将其构建成 HTML 字符串。在此过程中，React 会调用组件的生命周期方法，如 `componentWillMount`
3. 服务端响应：生成的 HTML 字符串随后被服务端通过 HTTP 响应发送给客户端。这个 HTML 是组件的初始渲染结果，包含了所有的标记和数据，但不包括事件处理器，因为它们是 JavaScript 代码。客户端收到 HTML 后，立即渲染页面，用户能直接看到内容而无需等待 JavaScript 加载执行
4. 客户端激活：为使页面完全交互，客户端的 React 代码会在 JavaScript 加载并执行后，激活这些静态 HTML。这个过程称为水合（Hydration），在此过程中，React 会为 DOM 添加事件监听器，并根据需要更新 DOM 以与客户端的初始状态完全匹配

###### 底层原理

- AST：`renderToString` 的底层实现涉及到将 JSX 转换为 AST，接着 AST 转换为虚拟 DOM，最后转换为 HTML 字符串，这一系列转换过程使得 React 能够高效处理组件渲染逻辑
- 流式渲染：React 还提供了 `renderToNodeStream` 方法，允许服务端以流的形式返回响应，这可以进一步提高首屏加载性能，因为浏览器可以直接接收并渲染 HTML 内容，而不必等待完整内容生成后开始

##### 同构

同构是指相同的代码既能在服务端渲染，也能在客户端执行，它既利用了 SSR 的优势，同时也保留了 CSR 的高交互和灵活性

1. 服务器端渲染：使用 `react-dom/server` 的 `renderToString` 或 `renderToNodeStream` 方法，将 React 组件（模板）渲染成初始的 HTML 字符串或流，使得服务端能够发送它们到浏览器，浏览器随后展示这个 HTML 内容，而无需等待所有的 JavaScript 下载并执行
2. 客户端激活：在客户端中使用 `react-dom` 的 `hydrateRoot` 对 SSR 的 HTML 进行水合，为 HTML 元素附加事件处理器，并确保客户端 React 应用的状态与 SSR 的结果一致

##### `ReactDOM.hydrateRoot`

- 保留 SSR 的 DOM 结构，在此基础上附加事件处理和状态管理的能力
- 确保客户端应用的初始状态与 SSR 相匹配，以避免不必要的重新渲染和闪烁
- 提供高性能的首屏加载体验，因为用户无需等待 JavaScript 下载和执行就可以看到完整的页面内容

###### 客户端路由 & 服务端路由

SSR 的路由处理有别于 CSR。在客户端渲染中，应用利用浏览器的 `history` API 如 `react-router-dom` 的 `BrowserRouter` 来响应 URL 的变化，动态渲染对应的组件，这种路由是有状态的，因为它依赖于浏览器环境和用户与页面的交互来维持应用的状态

相反，服务器端渲染不涉及用户与页面的直接交互，也无法访问浏览器的 `history` API 。此种情景下，路由需要以无状态的方式进行处理，这便是 `StaticRouter` 的用武之地。`StaticRouter` 用于 SSR。它不会监听 URL 的变化，也不会修改应用的状态。相反，它根据所提供的 `location` 属性来渲染对应的路由组件

客户端路由（React 路由）主要通过 JavaScript 在浏览器中控制，常见的实现方式是利用 React Router 等库来进行管理。当用户在应用内部进行页面跳转时，如点击链接、按钮等触发的导航事件，客户端路由会拦截这些请求并根据路由配置动态渲染对应的组件，而不会向服务端发送新的页面请求。这种方式实现了页面的快速响应和无刷新跳转，提升了用户体验

服务端路由（原生方式）处理则发生在服务端上。当用户通过地址栏输入 URL、刷新页面或使用 `<a>` 标签点击链接时，浏览器会向服务端发送一个新的请求。服务器根据请求的 URL，返回完整的 HTML 页面。服务端路由主要负责首次页面加载或通过非 React Router 控制的跳转时的页面渲染，如直接通过 URL 访问、刷新页面或使用 `<a>` 标签点击链接等