XSS：攻击者通过页面对用户输入过滤不足的漏洞，将恶意 HTML 或 JavaScript 注入至页面，当其他用户访问与该页面同源的目标页面时，这些恶意 HTML 或 JavaScript 继承目标页面的权限，在被攻击页面的同源上下文中执行，获取用户的敏感数据

1. 反射型 XSS：恶意脚本通过 URL 参数或表单提交等方式临时注入至请求中，服务端接收到请求后，将恶意脚本反射至页面，浏览器执行该恶意脚本
2. 存储型 XSS：恶意脚本存储于服务端，当用户访问包含该脚本的页面时，服务端将恶意脚本返回给浏览器，浏览器执行该恶意脚本
3. DOM 型 XSS：恶意脚本通过修改页面的 DOM 节点执行

防御：

- 通过转义函数和模板引擎过滤和转义输入以确保其不被解释为代码
- 避免使用 `eval`、`innerHTML` 和 `document.write` 等将字符串作为代码执行或插入 HTML 的 API
- 设置 Cookie 时，`HttpOnly` 防止 JavaScript 通过 `document.cookie` 获取，`Secure` 确保 Cookie 只通过 HTTPS 传输
- 通过 HTTP 头部字段或 HTML meta 标签的 Content Security Policy 限制页面可执行的脚本来源

CSRF：通过浏览器同源请求自动携带会话信息的机制，在用户已登录目标页面的情况下，攻击者诱使用户触发其构造的恶意请求，让目标页面误以为是用户的自发操作，从而执行未授权的恶意行为

防御：

- 服务端为各个用户会话生成唯一随机 Token 并将其嵌入到页面表单或请求，客户端请求时携带该 token，服务端验证请求中的 token 与会话中存储的 token 是否一致
- 对敏感操作要求用户通过密码、验证码或生物识别等方式进行二次验证
- 设置 Cookie 时，`SameSite` 属性设置为 `Strict` 或 `Lax` 以限制第三方请求自动携带 Cookie
- 服务端通过检查 HTTP 请求头部的 `Referer` 或 `Origin` 字段以验证请求来源是否合法
