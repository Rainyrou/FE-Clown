1. 浏览器缓存：当用户首次访问页面时，浏览器缓存页面资源如 HTML、CSS、JavaScript 和图片，当用户再次访问该页面时，浏览器直接从缓存中加载这些资源而无需再向服务端发送请求

- Memory Cache：体积较小或频繁访问的资源存储在内存中，浏览器关闭时即被清除
- Disk Cache：体积较大或很少访问的资源存储在硬盘中，持续时间长，但读取速度慢

2. 强缓存 & 协商缓存
3. LocalStorage & SessionStorage & Cookie & Session
4. Service Worker
5. IndexedDB：在浏览器中存储大量结构化数据的 API
6. 网关缓存如 Nginx 和 CDN
7. Redis

资源更新：线上静态资源（内容哈希 + 强缓存）已更新但浏览器页面尚未更新，可能为线上资源实际未更新成功或浏览器页面缓存资源

* 刷新即用户驱动浏览器调整缓存策略，缓存失效不等于缓存删除，磁盘缓存不因刷新被清除，仅为本次请求是否复用该缓存
* 手动刷新页面 F5：跳过强缓存，强制触发协商缓存，浏览器请求携带 `Cache-Control:max-age=0` 询问服务端资源是否更新
* 强制刷新页面 CTRL + F5：跳过强缓存 + 协商缓存，浏览器请求携带 `Cache-Control:no-cache` 向服务端请求新资源
* 地址栏回车/前进后退：优先命中强缓存，强缓存未命中再走协商缓存
- 通过 `[contenthash]` 命名文件，当文件内容变化时，`[contenthash]` 变化导致请求 URL 变化，浏览器直接请求新资源
* 在服务端或 CDN 实现版本控制，根据请求的版本标识符重定向至对应资源

优先级：强缓存 > 协商缓存

强缓存：客户端首次发送请求以获取服务端资源，服务端在响应头部中携带 `Cache-Control` 和 `Expires/Max-age` 字段，指定资源的缓存策略和过期时间，在此期间内，客户端不再向服务端请求同一资源而直接从本地获取

1. `Cache-Control`

- `max-age=<seconds>`：设置资源在本地的缓存期限
- `must-revalidate`: 缓存过期后，必须向服务端验证有效性
- `no-cache`：不使用本地缓存，每次请求均需向服务端验证有效性
- `no-store`：禁止任何形式的缓存
- `public`：响应可被任何缓存节点存储
- `private`：响应仅限于单用户，无法被共享缓存存储

2. Expires/Max-age

协商缓存：当强缓存过期或 `Cache-Control` 字段设置为 `no-cache` 时，客户端携带先前服务端返回的相关验证信息以询问服务端资源是否修改，若未修改，服务端返回 304，客户端继续使用本地缓存，否则服务端返回 200 和新资源

请求头：

- `If-Modified-Since`: 客户端将先前服务端返回的 `Last-Modified` 值置于请求头部以询问服务端资源是否修改
- `If-None-Match`: 客户端将先前服务端返回的 `ETag` 值置于请求头部以询问服务端资源是否修改

响应头：

- `Last-Modified`：标识资源最后修改时间
* `Etag`：资源唯一标识符，哈希值，用于判断服务端资源是否修改

强缓存 & 协商缓存区别：

* 强缓存由客户端控制，直接从客户端本地获取服务端资源，而协商缓存需客户端向服务器发送请求以确认服务端资源是否修改
* 强缓存返回 200，协商缓存返回 304 或 200
* 强缓存响应时间较快，因为无需网络请求，而协商缓存需等待服务端响应
* 强缓存通过 `Cache-Control` 和 `Expires` 实现，协商缓存通过 `ETag` + `If-None-Match` 和 `Last-Modified` + `If-Modified-Since` 实现

Last-Modified 局限性：

- 弱验证性：`Last-Modified` 仅根据资源最后修改时间判断而非资源内容本身
- 时间精度限制：`Last-Modified` 的时间精度为秒级，若资源在一秒内多次修改，`Last-Modified` 值无法反映最新状态，客户端无法获取最新资源
- 时间同步问题：`Last-Modified` 值依赖于服务端的时间设置且验证逻辑为服务端当前资源时间 vs 客户端传递的时间，若服务端时间错误或客户端和服务端存在时差，则影响协商缓存的验证

Etag 局限性：

* 性能开销：`ETag` 的生成依赖于资源本身，强验证基于资源完整内容计算，修改任何字节均导致 `ETag` 值变化，因此服务端每次处理缓存请求时重新读取完整资源内容并计算哈希，增加大量服务端 CPU 和 I/O 开销
* 弱验证模糊：弱验证基于资源部分元数据如文件大小或修改时间等或模糊内容哈希计算，允许资源发生非实质性的变化而 `ETag` 不变，HTTP 未明确规定弱验证的具体标准，因此不同服务端对弱验证实现不一致导致生成的 `ETag` 值不同
* 分布式系统的一致性：在分布式系统中，若同一资源在不同服务端的 `ETag` 计算逻辑存在差异则导致生成的 `ETag` 值不同