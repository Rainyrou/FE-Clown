取消请求：

* Axios：通过 `CancelToken` 创建取消令牌，在发送请求时携带，通过调用 `cancel` 取消请求
* XMLHttpRequest：通过调用 `XMLHttpRequest.abort` 取消请求
* Fetch：通过 `AbortController` 创建实例信号，在发送请求时携带，当信号触发时通过 `abort` 取消请求
* WebSocket：通过调用 `WebSocket.close` 取消请求

移除重复请求：

* 请求状态缓存池：通过键值对存储请求状态，重复请求复用同一结果
* 取消重复请求
* 防抖节流：延迟请求执行，合并短时间内的重复请求，防抖 -> 同一标识的请求触发后，延迟执行，若在指定期间再次触发，重置延迟时间，仅执行最后一次请求；节流 -> 同一标识的请求在指定期间触发一次
* 版本号/Token 去重：为各个请求生成唯一版本号或 Token，通过版本更新取消旧请求，执行新请求
* 前后端协同去重：前端前置去重，服务端为各个幂等请求分配唯一标识，接收到请求后根据标识判断请求是否处理，若未处理则执行业务逻辑并记录标识状态，否则直接返回先前的处理结果

分页时后请求先响应导致数据覆盖，确保显示最后选中页的方法：无论响应顺序如何，只处理用户最后一次请求的响应数据

* 切换页面时主动取消上一次未完成的请求
* 各个请求生成唯一标识，前端存储最新请求标识，返回响应时验证标识有效性，当响应标识与存储的最新标识匹配时才处理响应，否则直接忽略

GET：请求以获取服务端资源而非对其产生副作用（安全 + 幂等 + 可缓存），无请求体
POST：请求以更新服务端资源（不安全 + 不幂等 + 不可缓存），有请求体
PUT：请求以全量更新服务端资源（不安全 + 幂等 + 不可缓存），有请求体
DELETE：请求以删除服务端资源（不安全 + 幂等 + 不可缓存），可选请求体）

POST 请求实现 DELETE & UPDATE：

* 在 URL 路径中嵌入资源 ID + 操作类型，服务端解析 URL 获取客户端操作意图并执行对应逻辑
* 客户端在 POST 请求的 `X-HTTP-Method-Override/X-Action` 头部字段中声明 DELETE & UPDATE，服务端拦截该请求，检查该字段，若存在则在内部重写请求方法以执行 DELETE & UPDATE 操作


