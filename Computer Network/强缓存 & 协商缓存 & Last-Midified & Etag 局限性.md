强缓存：客户端首次发送请求以获取服务端资源，服务端在响应头部中携带 `Cache-Control` 和 `Expires/Max-age` 字段，指定资源的缓存策略和过期时间，在此期间内，客户端不再向服务端请求同一资源而直接从本地获取

1. `Cache-Control`

- `max-age=<seconds>`：设置资源在本地的缓存期限
- `must-revalidate`: 缓存过期后，必须向服务端验证有效性
- `no-cache`：不使用本地缓存，每次请求均需向服务端验证有效性
- `no-store`：禁止任何形式的缓存
- `public`：响应可被任何缓存节点存储
- `private`：响应仅限于单用户，无法被共享缓存存储

2. Expires/Max-age

协商缓存：当强缓存过期或 `Cache-Control` 字段设置为 `no-cache` 时，客户端携带先前服务端返回的相关验证信息以询问服务端资源是否修改，若未修改，服务端返回 304，客户端继续使用本地缓存，否则服务端返回 200 和新资源

请求头：

- `If-Modified-Since`: 客户端将先前服务端返回的 `Last-Modified` 值置于请求头部以询问服务端资源是否修改
- `If-None-Match`: 客户端将先前服务端返回的 `ETag` 值置于请求头部以询问服务端资源是否修改

响应头：

- `Last-Modified`：标识资源最后修改时间
* `Etag`：资源唯一标识符，哈希值，用于判断服务端资源是否修改

强缓存 & 协商缓存区别：

1. 强缓存由客户端控制，直接从客户端本地获取服务端资源，而协商缓存需客户端向服务器发送请求以确认服务端资源是否修改
2. 强缓存返回 200，协商缓存返回 304 或 200
3. 强缓存响应时间较快，因为无需网络请求，而协商缓存需等待服务端响应
4. 强缓存通过 `Cache-Control` 和 `Expires` 实现，协商缓存通过 `ETag` + `If-None-Match` 和 `Last-Modified` + `If-Modified-Since` 实现

Last-Modified 局限性：

- 弱验证性：`Last-Modified` 仅根据资源最后修改时间判断而非资源内容本身
- 时间精度限制：`Last-Modified` 的时间精度为秒级，若资源在一秒内多次修改，`Last-Modified` 值无法反映最新状态，客户端无法获取最新资源
- 时间同步问题：`Last-Modified` 值依赖于服务端的时间设置且验证逻辑为服务端当前资源时间 vs 客户端传递的时间，若服务端时间错误或客户端和服务端存在时差，则影响协商缓存的验证

Etag 局限性：

* 性能开销：`ETag` 的生成依赖于资源本身，强验证基于资源完整内容计算，修改任何字节均导致 `ETag` 值变化，因此服务端每次处理缓存请求时重新读取完整资源内容并计算哈希，增加大量服务端 CPU 和 I/O 开销
* 弱验证模糊：弱验证基于资源部分元数据如文件大小或修改时间等或模糊内容哈希计算，允许资源发生非实质性的变化而 `ETag` 不变，HTTP 未明确规定弱验证的具体标准，因此不同服务端对弱验证实现不一致导致生成的 `ETag` 值不同
* 分布式系统的一致性：在分布式系统中，若同一资源在不同服务端的 `ETag` 计算逻辑存在差异则导致生成的 `ETag` 值不同