##### 路由懒加载

当一个项目首次运行时，一次性加载所有的 JavaScript 和 CSS 文件会导致显著的性能瓶颈。这是因为浏览器需要下载、解析并执行所有这些资源，才能完全显示页面，此过程可能会消耗大量的时间，特别是在网络条件不佳的情况下。路由懒加载的思想是按需加载，即只有当用户访问到某个路由时，才加载该路由对应的资源文件

- 减少初始加载的资源量，提升首屏加载速度，用户可以更快地看到首屏内容
- 对于不访问的页面不下载资源，可以节约带宽
- 减轻服务端的负担，因为资源是根据需求分批加载的，避免一次性处理大量请求的压力

在 Vue 中，路由懒加载可通过动态 `import()` 语法实现，其为 ES6 的特性，允许你异步加载模块

```JavaScript
const Home = () => import(/* webpackChunkName: "home" */ './views/Home.vue');

const routes = [
  {
    path: '/',
    name: 'Home',
    component: Home
  }
];
```

###### 原理

1. 使用 `import()` 函数动态导入 Vue 组件，Webpack 在打包时会将这些组件分割成单独的 chunk，而 `webpackChunkName` 注释允许我们为这些异步加载的 chunk 命名，便于识别和管理
2. 在使用路由懒加载时，Webpack 会结合 Vue-router 的配置，自动将应用分割成多个 chunk。这个过程中，Webpack 会分析应用，找到那些通过动态 `import()` 引入的模块，并将它们分割成独立的文件
3. 当用户访问某个路由时，Vue-router 会请求 Webpack 分割出来的对应 chunk，浏览器会异步加载这个文件，然后渲染对应的组件。这个过程是完全自动的，开发者只需要通过动态 `import()` 引入路由组件即可


`SplitChunksPlugin` 是 Webpack 内置的插件，用于优化和分割 chunk。可根据需要在 `vue.config.js` 文件中自定义配置。如设置分割点、命名规则、选择哪些模块分割等

##### 图片懒加载

懒加载：图片在页面首次加载时不会立即下载，只有当用户滚动到图片的可视区域时，图片才会被加载

- 页面初次加载时，图像元素不包含实际的 `src` 属性，或指向一个轻量级的占位图
- 当用户滚动页面，接近图像的位置时，JavaScript 代码检测到图像即将出现在视口中
- JavaScript 动态更新图像的 `src` 属性，使其指向实际的图像资源，浏览器随后加载并显示该图像

```JavaScript
<image lazy-load v-for="(item,index) in data" :src="item" />
```

###### JS IntersectionObserver API

```JavaScript
const images = document.querySelectorAll('img');

// `entries`包含所有被观察的元素的交叉信息
const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
	    // 检查当前元素是否进入了视口
        if(entry.isIntersecting) {
	        // `entry.target` 直接引用被观察的目标元素，`target` 指向被观察的 DOM 元素
            const img = entry.target;
            // 自定义属性 `data-src` 存放真正的图片 URL，原本 `img` 自带的 `src` 存放默认图片 URL
            const data_src = img.getAttribute('data_src');
            img.setAttribute('src', data_src);
            // 调用 `unobserve` 方法解除对该图片的观察，因为不再需要监视已加载的图片
            observer.unobserve(img);
        }
    })
});

images.forEach((image) => observer.observe(image));
```

`IntersectionObserver` 用于异步观察目标元素与其祖先元素或顶级文档 viewport 的交叉状态。当被观察的元素进入或退出视口时，它可以高效触发回调函数，而不需要使用传统的滚动事件监听器和 `getBoundingClientRect` 等方法 `IntersectionObserver` 可在不阻塞主线程的情况下工作，提供更好的性能和响应性

###### HTML5 loading

```HTML
<img src="image.jpg" loading="lazy" alt="...">
```

##### Vue

###### 自定义指令

```JavaScript
Vue.directive('lazy', {
    inserted: (el, binding) => {
        const observer = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    el.src = binding.value;
                    observer.unobserve(el);
                }
            });
        });
        observer.observe(el);
    }
});
```

在模板中使用：

```HTML
<img v-lazy="imageURL">
```

###### 第三方库

```bash
npm install vue-lazyload --save
```

```JavaScript
import Vue from 'vue';
import VueLazyload from 'vue-lazyload';

Vue.use(VueLazyload);

Vue.use(VueLazyload, {
    preLoad: 1.3,
    error: 'dist/error.png',
    loading: 'dist/loading.gif',
    attempt: 1
});
```

```HTML
<img v-lazy="imageURL">
```

##### React

###### React hooks

```JSX
function useLazyLoad(imgRef) {
    useEffect(() => {
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    img.src = img.dataset.src;
                    observer.unobserve(img);
                }
            });
        });

        observer.observe(imgRef.current);

        return () => {
            if (imgRef.current) {
                observer.unobserve(imgRef.current);
            }
        };
    }, [imgRef]);
}

function ImageComponent({ src }) {
    const imgRef = useRef(null);
    useLazyLoad(imgRef);

    return <img ref={imgRef} data-src={src} alt="Lazy loaded" />;
}
```

###### 第三方库

```bash
npm install react-lazy-load-image-component --save
```

```JSX
import { LazyLoadImage } from 'react-lazy-load-image-component';

function ImageComponent({ src }) {
    return <LazyLoadImage src={src} effect="blur" />;
}
```
