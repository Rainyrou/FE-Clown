##### 路由懒加载

当一个项目首次运行时，一次性加载所有的 JavaScript 和 CSS 文件会导致显著的性能瓶颈。这是因为浏览器需要下载、解析并执行所有这些资源，才能完全显示页面，此过程可能会消耗大量的时间，特别是在网络条件不佳的情况下。路由懒加载的思想是按需加载，即只有当用户访问到某个路由时，才加载该路由对应的资源文件

- 减少初始加载的资源量，提升首屏加载速度，用户可以更快地看到首屏内容
- 对于不访问的页面不下载资源，可以节约带宽
- 减轻服务端的负担，因为资源是根据需求分批加载的，避免一次性处理大量请求的压力

在 Vue 中，路由懒加载可通过动态 `import()` 语法实现，其为 ES6 的特性，允许你异步加载模块

```JavaScript
const Home = () => import(/* webpackChunkName: "home" */ './views/Home.vue');

const routes = [
  {
    path: '/',
    name: 'Home',
    component: Home
  }
];
```

###### 原理

1. 使用 `import()` 函数动态导入 Vue 组件，Webpack 在打包时会将这些组件分割成单独的 chunk，而 `webpackChunkName` 注释允许我们为这些异步加载的 chunk 命名，便于识别和管理
2. 在使用路由懒加载时，Webpack 会结合 Vue-router 的配置，自动将应用分割成多个 chunk。这个过程中，Webpack 会分析应用，找到那些通过动态 `import()` 引入的模块，并将它们分割成独立的文件
3. 当用户访问某个路由时，Vue-router 会请求 Webpack 分割出来的对应 chunk，浏览器会异步加载这个文件，然后渲染对应的组件。这个过程是完全自动的，开发者只需要通过动态 `import()` 引入路由组件即可

`SplitChunksPlugin` 是 Webpack 内置的插件，用于优化和分割 chunk。可根据需要在 `vue.config.js` 文件中自定义配置。如设置分割点、命名规则、选择哪些模块分割等

##### 图片懒加载

懒加载：图片在页面首次加载时不会立即下载，只有当用户滚动到图片的可视区域时，图片才会被加载

- 页面初次加载时，图像元素不包含实际的 `src` 属性，或指向一个轻量级的占位图
- 当用户滚动页面，接近图像的位置时，JavaScript 代码检测到图像即将出现在视口中
- JavaScript 动态更新图像的 `src` 属性，使其指向实际的图像资源，浏览器随后加载并显示该图像

```JavaScript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Optimized lazyLoad</title>
</head>
<style>
    .container {
        width: 1000px;
        margin: 0 auto;
        background-color: pink;
    }
    .container > img {
        display: block;
        width: 400px;
        height: 400px;
        margin-bottom: 50px;
    }
</style>
<body>
<div class="container">
    <img src="./img/loading.jpg" data-src="./img/pic1.png" alt="Lazy Image">
    <img src="./img/loading.jpg" data-src="./img/pic2.png" alt="Lazy Image">
    <img src="./img/loading.jpg" data-src="./img/pic3.png" alt="Lazy Image">
    <img src="./img/loading.jpg" data-src="./img/pic4.png" alt="Lazy Image">
    <img src="./img/loading.jpg" data-src="./img/pic5.png" alt="Lazy Image">
    <img src="./img/loading.jpg" data-src="./img/pic6.png" alt="Lazy Image">
</div>
<script>
    const imgs = document.querySelectorAll('img[data-src]');

    const lazyLoad = () => {
        imgs.forEach(img => {
            const rect = img.getBoundingClientRect();
            if (rect.top < window.innerHeight && !img.classList.contains('loaded')) {
                img.src = img.getAttribute('data-src');
                img.classList.add('loaded'); // 标记为已加载
            }
        });
    };

    const debounce = (fn, delay) => {
        let timer = null;
        return function (...args) {
            clearTimeout(timer);
            timer = setTimeout(() => fn.apply(this, args), delay);
        };
    };

    window.addEventListener('load', lazyLoad);
    window.addEventListener('scroll', debounce(lazyLoad, 200));
    window.addEventListener('resize', debounce(lazyLoad, 200));
</script>
</body>
</html>
```

###### 主要改进点

1. **避免重复加载**：通过给每个已加载的图片添加一个 `loaded` 类，我们可以确保同一图片不会被重复加载，这减少了不必要的网络请求，提高了页面性能和用户体验
2. **性能优化**：通过使用 `debounce` 函数优化了滚动和窗口调整大小事件的处理，避免在短时间内频繁调用 `lazyLoad` 函数，提高了页面性能和用户体验
3. **改进懒加载条件**：通过检查元素是否在视口内即 `rect.top < window.innerHeight`，只有当图片进入视口时才加载图片，这符合懒加载的预期行为
4. **使用 classList 管理类名**：使用 `classList.add` 方法给图片添加 `loaded` 类，比直接操作 `className` 属性更清晰
