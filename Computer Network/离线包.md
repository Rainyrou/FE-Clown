1. 预下载和存储：将静态资源打包为压缩文件并生成对应的版本号和 Manifest，在 Web 端中使用  Service Worker + Cache API/IndexedDB，而在移动端中存储于 App 的私有目录

预下载的时机：

- 应用安装后首次启动时后台下载
- 用户主动触发更新
- 通过长连接或推送通知检测新版本并静默更新

2. 请求拦截：应用启动时注册网络拦截器，监听所有 HTTP 请求，当请求命中离线包资源时，在 Web 端中通过 Service Worker  监听  `fetch`  事件匹配请求 URL 后返回缓存内容，而在移动端中通过  `WebViewClient.shouldInterceptRequest`  拦截请求，将请求重定向到本地文件
3. 版本控制：每次发布离线包时生成唯一版本号如  `v1.0.0`，客户端通过版本号判断是否需要更新
4. 增量更新：服务端通过哈希值比对新旧 Manifest，仅下发变化的文件，客户端合并增量包
5. 容灾回退：若新版本离线包加载失败则自动回退到旧版本
6. 缓存更新：客户端冷启动时检查离线包版本，若过期则在后台静默下载新包并于下次启动时生效，用户无感知，此外可在进入特定页面时触发对应页面的缓存更新

Manifest 记录资源路径、哈希值和依赖关系等元数据

```json
{
  "version": "v1.2.0",
  "files": [
    { "url": "/static/js/main.js", "hash": "a1b2c3" },
    { "url": "/static/img/logo.png", "hash": "d4e5f6" }
  ]
}
```

| 方案               | 实现方式                 | 优点                 | 缺点                  |
| ---------------- | -------------------- | ------------------ | ------------------- |
| 原生离线包            | App 内置拦截逻辑 + ZIP 包管理 | 性能高，原生体验           | 需原生开发支持             |
| Service Worker   | 基于浏览器的缓存拦截机制         | 纯 Web 实现，跨平台       | 兼容性问题               |
| React Native 离线包 | Metro 打包 + 本地存储      | 兼容 React Native 生态 | 局限于 React Native 应用 |

