1. 预下载和存储：将静态资源打包为压缩文件并生成对应版本号和 Manifest，在 Web 端中通过 Service Worker + Cache API/IndexedDB 存储，而在移动端中存储于 APP 私有目录

预下载的时机：

- 应用安装后首次启动时后台下载
- 用户主动触发更新
- 通过长连接或推送通知检测新版本并静默更新

2. 请求拦截：应用启动时注册请求拦截器并监听所有请求，当请求命中离线包资源时，在 Web 端中通过 Service Worker 监听 `fetch`  事件匹配请求 URL 后返回缓存内容，而在移动端中通过  `WebViewClient.shouldInterceptRequest`  拦截请求并将其重定向至本地文件
3. 版本控制：发布离线包时生成唯一版本号，客户端通过版本号判断是否需要更新
4. 增量更新：服务端通过哈希值比较新旧 Manifest，仅下发变化的文件，客户端合并增量包
5. 容灾回退：若新版本离线包加载失败则自动回退至旧版本
6. 缓存更新：客户端冷启动时检查离线包版本，若过期则在后台静默下载新包并于下次启动时生效（用户无感知），此外可在进入特定页面时触发对应页面的缓存更新

Manifest 记录资源路径、哈希值和依赖关系等元数据

```json
{
  "version": "v1.2.0",
  "files": [
    { "url": "/static/js/main.js", "hash": "a1b2c3" },
    { "url": "/static/img/logo.png", "hash": "d4e5f6" }
  ]
}
```

| 方案               | 实现方式                 | 优点                 | 缺点                  |
| ---------------- | -------------------- | ------------------ | ------------------- |
| 原生离线包            | App 内置拦截逻辑 + ZIP 包管理 | 性能高，原生体验           | 需原生开发支持             |
| Service Worker   | 基于浏览器的缓存拦截机制         | 纯 Web 实现，跨平台       | 兼容性问题               |
| React Native 离线包 | Metro 打包 + 本地存储      | 兼容 React Native 生态 | 局限于 React Native 应用 |

