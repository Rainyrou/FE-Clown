[【offer 收割机之面试必备】一篇非常全面的 从 URL 输入到页面展现的全过程 精华梳理 - 掘金](https://juejin.cn/post/7081638674860867621#heading-0)

1. 解析用户输入内容（关键字还是 URL）
2. 看是否命中强缓存（没有则继续下一步）
3. DNS 解析（将域名转化为 IP 地址）
4. 建立 TCP 连接（三次握手）
5. 发送 HTTP 请求（先看是否命中协商缓存，有则 304，没有则 200 和新资源）并接收对应响应报文
6. 关闭 TCP 连接（四次挥手）
7. 提交文档
8. 浏览器渲染

##### 1. 解析用户输入内容（关键字还是 URL）

用户在地址栏输入内容之后，浏览器会首先判断用户输入的是合法的 URL 还是搜索内容，如果是搜索内容就合成 URL，如果是合法的 URL 就开始进行加载

如果是合法的 URL，说明我们想通过该 URL(统一资源定位符) 查找到对应服务器上的资源，查找的实质就是该域名解析后所对应的 IP 地址，即域名与 IP 地址的一个映射关系

##### 2. 查找强制缓存

有效期内的缓存资源直接使用，称之为强缓存，从 Chrome 网络面板看到这类请求直接返回 200

- 浏览器首次加载资源成功时，服务器返回 200，此时浏览器不仅将资源下载下来，而且把 Response 的 Header(里面的 date 属性非常重要，用来计算第二次相同资源时当前时间和 date 的时间差)一并缓存
- 下一次加载资源时，首先要经过强缓存的处理。强缓存是利用 HTTP 请求头中的 `Expires` 和 `Cache-Control` 两个字段来控制的。在强缓存中，当请求再次发出时，浏览器会根据其中的 `Expires` 和 `Cache-Control` 判断目标资源是否"命中"强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。其中 `Cache-Control` 的优先级最高，如果 `Cache-Control：no-cache`，就直接进入到协商缓存的步骤了，如果 `Cache-Control：max-age=xxx`，就会先比较当前时间和上一次返回 200 时的时间差，如果没有超过 max-age，命中强缓存，不发请求直接从本地缓存读取该文件（这里需要注意，如果没有 `Cache-Control`，会取 `Expires` 的值，来对比是否过期），过期的话会进入下一个阶段

##### 3. DNS 解析

DNS 解析将对应的域名转化为 IP 地址

浏览器 DNS 缓存 -> OS 本地 `host` 文件 -> OS DNS 缓存 -> 网络请求 -> 本地服务器 -> 根域名服务器 -> 顶级域名服务器 -> 权威域名服务器

DNS (Domain Name System) 作为域名和 IP 地址之间的映射系统，允许人们使用易于记忆的域名（如 `example.com`）来访问特定的服务器，而服务器实际上是通过 IP 地址（如 `192.168.1.1`）来定位的

###### DNS 查询流程：

1. 当用户在浏览器中输入一个 URL 并按 Enter 键后，浏览器会首先查找自己的 DNS 缓存（这个缓存只有浏览器自己可以访问）看是否已经存储了这个域名对应的 IP 地址
2. 如果没有找到，操作系统会检查本地的 `hosts` 文件。`hosts` 文件是一个系统文件，允许手动映射域名到特定的 IP 地址
3. 如果没有找到，操作系统会查找自己的 DNS 缓存是否有这个域名对应的 IP 地址
4. 如果上述步骤都没有找到域名对应的 IP 地址，操作系统会将 DNS 查询请求发送到本地网络配置中指定的 DNS 服务器。这个服务器通常是由 ISP（Internet Service Provider）提供的
5. 如果本地 DNS 服务器没有缓存该域名对应的 IP 地址，它开始一个迭代查询过程：询问根 DNS 服务器->根据根 DNS 服务器的指引，询问相应的顶级域（TLD）服务器（如 `.com`、`.org` 等）->根据 TLD 服务器的指引，询问权威 DNS 服务器(二级域名和更多级的域名都在权威域名服务器解析)
6. 权威 DNS 服务器回应本地 DNS 服务器查询请求，提供域名对应的 IP 地址，或者返回一个错误（如域名不存在）
7. 本地 DNS 服务器将查询结果（无论是 IP 地址还是错误）缓存一定时间（根据 DNS 记录的 TTL，即 Time to Live 值决定），以便下次有相同的查询请求时，可以直接从缓存中提供答案
8. 本地 DNS 服务器将查询结果返回给发起查询的客户端程序
9. 客户端程序（如操作系统或 Web 浏览器）可能也会缓存这个结果，以便将来需要时能更快地解析相同的域名

- 分层为了通过负载均衡来分散压力，三级分层（根域名服务器、顶级域名服务器、权威域名服务器）在实践中被证明是既能满足全球互联网需求，又能保持稳定和有效的一个层次

##### 4. 建立 TCP 连接

1. 首先等待 TCP 队列

Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果超过这个数量的连接必须要进入排队等待状态。对于多路复用，HTTP 1.1 采取建立多个 TCP 连接，HTTP 2.0 采用建立一个 TCP 连接并行发起多个请求

2. 正式开始建立 TCP 连接

通过 TCP 三次握手与服务器建立连接，然后进行数据传输

![[Pasted image 20231030070246.png]]

一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态

![[Pasted image 20231030070719.png]]

客户端会随机初始化序号( client_isn） ，将此序号置于 TCP 首部的|序号|字段中，同时把 SYN 标志位置为 1 ，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态

![[Pasted image 20231030070656.png]]

服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号 ( server_isn )，将此序号填入
TCP 首部的|序号|字段中，其次把 TCP 首部的|确认应答号|字段填入 client_isn + 1，接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态

![[Pasted image 20231030070934.png]]

客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次|确认应答号|字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 ESTABLISHED 状态。服务器收到客户端的应答报文后，也进入 ESTABLISHED 状态

从上面的过程可以发现第三次握手是可以携带数据的，前两次握手是不可以携带数据的，这也是面试常问的题

一旦完成三次握手，双方都处于 ESTABLISHED 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了

##### 5. 发送 HTTP 请求并接收相应结果

1. 先看是否命中协商缓存

- 有则返回状态码 304 并更新资源标识符
- 没有则返回状态码 200 和新资源

> 超过有效期的，则携带缓存的资源标识向服务端发起请求，校验是否能继续使用，如果服务端告诉我们，可以继续使用本地存储，则返回 304，并且不携带数据；如果服务端告诉我们需要用更新的资源，则返回 200，并且携带更新后的资源和资源标识缓存到本地，方便下一次使用

2. 然后接收对应响应报文

服务器首先返回相应行，包括协议版本和状态码，然后会返回响应头包含返回的数据类型，服务器要在客户端保存的 `Cookie` 等，一般来说是返回 HTML、CSS、JS、Image 文件

###### 对于是否命中协商缓存

- 协商缓存阶段，则向服务器发送 Header 带有 `If-None-Match` 和 `If-Modified-Since` 的请求，前者优先级大于后者。请求头的 `If-None-Match` 和响应头的 `Etag`。服务器会比较这两个字段值，如果相同，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 `Etag` 值并返回 200
- 协商缓存第二个对应关系是 `If-Modified-Since` 和 `Last-modified`，如果客户端发送的 If-Modified-Since 的值跟服务器端获取的文件最近改动的时间，一致则命中协商缓存，返回 304；不一致则返回新的 `Last-modified` 和文件并返回 200

###### 为什么协商缓存中 Etag 优先级大于 Last-modified ？

因为后者是标识着资源的最后修改时间(不准确，因为修改了文件并不代表文件内容发生改变，可能改变后又撤销了)，前者可以理解为是一个资源唯一标识符，是服务器通过内置算法根据文件内容生成的 `hash` 值，所以更准确，当然，因为计算所以性能消耗更大，不太推荐使用 `Etag`

##### 6. 关闭 TCP 连接

数据传输完成后，通过四次挥手来断开连接

![[Pasted image 20231030071543.png]]

- 客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态
- 服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态
- 客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态
- 等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态
- 客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态
- 服务器收到了 ACK 应答报文后，就进入了 CLOSED 状态，至此服务端已经完成连接的关闭
- 客户端在经过 2MSL 一段时间后，自动进入 CLOSED 状态，至此客户端也完成连接的关闭

##### 7. 提交文档阶段

1. 网络进程将获取的数据进行解析，根据响应头中的 `Content-Type` 来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器去下载，如果是 `text/html` 类型，就通知浏览器进程获取到的是 HTML，准备渲染进程
2. 一般情况下浏览器的一个 tab 页面对应一个渲染进程，如果从当前页面打开的新页面并且属于同一站点，这种情况会复用渲染进程，其他情况则需要创建新的渲染进程
3. 渲染进程准备好之后，浏览器会发出提交文档的消息给渲染进程，渲染进程收到消息后，会和网络进程建立数据传输的管道（IPC），文档数据传输完成后，渲染进程会返回确认提交的消息给浏览器进程
4. 浏览器收到确认提交的消息后，会更新浏览器的页面状态，包括了安全状态，地址栏的 URL，前进后退的历史状态，并更新 web 页面为空白

##### 8. 浏览器渲染阶段

**前置知识**

- 在浏览器获取到 HTML 文件后，由于无法直接理解与使用 HTML，所以先将它转换为能够读懂的 DOM 树结构
- CSS 文件一样没法被浏览器直接理解，所以首先把 CSS 解析成样式表。这三类样式都会被解析：
  - 通过 link 引用的外部 CSS 文件（外联）
  - `<style>` 标签内的样式（内联）
  - 元素的 style 属性内嵌的 CSS（行内样式）

###### 工作流程

- 浏览器解析 HTML 文档，构建 DOM 树。DOM 树是文档的对象表示，它包含页面所有元素及其属性和层次结构

* 浏览器解析 CSS 样式，解析后构建 CSSOM（CSS Object Model）树

- 浏览器结合 DOM 树和 CSSOM 树构建 Render 树，渲染树只包含需要渲染的节点及其样式，隐藏的元素如 `display: none` 不包含在渲染树中

* 布局阶段，浏览器计算出渲染树中每个节点的确切位置和大小
* 浏览器对渲染树的每个节点进行绘制，包括文本图像内容、颜色、边框、阴影等

- 页面的某些部分可能在单独的图层上进行绘制，浏览器合并这些图层，生成最终图像
