1. token 生成 & 过期 & 验证：`login` 方法通过用户名查询数据库，确认用户存在且密码正确，通过插件生成一个有效期为 24 小时的 token，`login` 第一个参数为一个包含用户 id、姓名和 token 过期时间的对象，它在 token 中编码但未被加密，因此不应含敏感数据如密码，第二个参数为从 `app.config.jwt.secret` 获取的密钥，用于 token 签名，确保 token 在传输过程中没有被篡改，最后通过 `app.jwt.verify` 方法验证 token 的有效性，该方法解码 token，并使用之前设置的密钥验证其签名，若 token 有效，返回 token 中编码数据即用户 id、姓名和 token 过期时间，这样服务端可以识别和授权用户，若 token 过期或无效则抛出错误，要求用户重新登录以获取新的 token，后续在服务端设置一个中间件实现 token 自动刷新，即 token 即将过期服务端返回新 token 给客户端，提高用户体验，避免频繁手动重新登录。在生成 Refresh token 时，将其与用户 ID 关联并存储在 Redis 中，创建一个端点如 `/refresh_token`，客户端发送 Refresh token 到该端点来获取一个新的 Access token，在用户请求刷新 Access token 时，检查 Refresh token 是否在 Redis 中并验证其有效性，如果有效，则生成一个新的 Access token 并返回给客户端，用户退出登录时，通过 `client.del(refreshToken)` 从 Redis 中移除对应的 Refresh token
2. token 保存：生成的 token 未在服务端保存，它作为响应的一部分返回给客户端，因为 JWT 实现无状态化，无需在服务端持久化 token，而是依靠客户端存储和在随后的请求中携带 token。客户端将其保存在 LocalStorage 中，每次发送请求时，在 HTTP 请求头部的的 `Authorization` 字段携带该 token，我是通过 Axios 全局默认配置，从 LocalStorage 中拿到它的，客户端将 token 存储在 LocalStorage 虽为常见做法，但难抵 XSS 攻击，后续将 token 存储于 HttpOnly 的 Cookie，确保通信均通过 HTTPS 进行

双 token 机制：Access Token 用于访问受保护的资源如 API，客户端在有效期内可用其认证状态和访问权限，其具有较短的有效期，风险相对较低，即便被泄露，攻击者也只能在短时间内使用它，Refresh Token 用于在 Access Token 过期后获取一个新的 Access Token，无需用户再次登录，Refresh Token 有更长的有效期，其安全性比 Access Token 高，因为它只用于与认证服务端通信，而不是直接用来访问受保护资源
