1. 冒泡排序：

- 时间复杂度：最好情况 -> O(n) + 数组完全有序，最坏情况 -> O(n²) + 数组完全逆序，平均情况 -> O(n²)
* 空间复杂度：O(1) -> 原地排序

2. 选择排序：

- 时间复杂度：最好/最坏/平均情况 -> O(n²) + n-1 次选择
* 空间复杂度：O(1) -> 原地排序

3. 插入排序：

- 时间复杂度：最好情况 -> O(n) + 数组完全有序，最坏情况 -> O(n²) + 数组完全逆序，平均情况 -> O(n²)
* 空间复杂度：O(1) -> 原地排序

4. 快速排序：

- 时间复杂度：最好/平均情况 -> O(n log n) ，最坏情况 -> O(n²) + 选取基准为最小或最大元素
* 空间复杂度：O(log n)/O(n) -> 递归深度

5. 归并排序：

- 时间复杂度：最好/最坏/平均情况 -> O(n log n) + 始终遍历所有元素并进行合并
* 空间复杂度：O(n) -> 创建一个与原数组相同大小的辅助数组来合并分组

6. 希尔排序：

- 时间复杂度：最好情况 -> O(n log n) + 间隔序列，最坏情况 -> O(n(log n)²)
* 空间复杂度：O(1) -> 原地排序

7. 堆排序

- 时间复杂度：最好/最坏/平均情况 -> O(n log n)
* 空间复杂度：O(1) -> 原地排序

8. 桶排序

- 时间复杂度：最好情况 -> O(n+k) ，最坏情况 -> O(n²) + 所有元素分配于同一桶，平均情况 -> O(n+k)
* 空间复杂度：O(n+k) -> 需额外空间来存储桶

9. 计数排序

- 时间复杂度：最好/最坏/平均情况 -> O(n+k) + k 为输入数据的范围
* 空间复杂度：O(k) -> 需额外空间来存储计数数组

10. 基数排序

- 时间复杂度：最好/最坏/平均情况 -> O(nk) + k 为数字的最大位数
* 空间复杂度：O(n+k) -> 需额外空间来存储数位
