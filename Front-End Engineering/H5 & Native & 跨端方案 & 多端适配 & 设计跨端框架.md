H5/Native/跨端方案：

- 结论（10s）：我认为核心在于解决不可能三角的平衡问题，Native 追求用户留存，H5 追求敏捷开发，跨端追求投入产出比，取舍的本质为业务场景的优先级匹配
- 落地细节（240s）：基于不同业务实践，我给出三类方案的优劣与取舍逻辑：
  1. H5：核心优势是「极致动态化 + 零跨端成本」—— 营销活动/官网可秒级发版，无包体积压力；核心劣势是「性能天花板低 + 原生能力弱」—— 复杂动画容易卡顿，首屏 LCP 需要依赖 SSR /接口预请求提升至 1.5s 内，原生能力调用需要封装 Bridge，适配成本较高
  2. Native：核心优势是「性能拉满 + 能力全量 + 体验原生」—— 跟手动画稳定 60fps，支付/风控等核心业务场景安全性最高，系统 API 调用无限制；核心劣势是「开发成本翻倍 + 动态化缺失」—— 双端各自独立开发维护，发版周期依赖应用商店审核，紧急 Bug 修复无法快速上线
  3. 跨端：核心优势是「开发效率与用户体验的平衡」—— 一次开发多端复用，开发成本比 Native 低 50%，性能却接近于 Native；核心劣势是「生态依赖 + 定制成本高」——跨端框架生态远逊于 H5/Native，需要自研封装，复杂原生能力（如 AR/游戏）适配难度大，且多端一致性需要额外打磨
* 取舍逻辑（45s）：基于上述思考和业界调研，我会在实战中设计 APP 融合型架构，底层由 Native 提供高性能容器和系统桥接，以及承接支付/风控等核心业务，中层通过跨端方案承载 80% 的中高频业务，上层通过 H5 承接营销活动和官网

多端适配：

- 结论（10s）：我认为多端适配的核心在于工程化提效与分层降级
- 落地细节（240s）： 我分为四个方面的适配：
  1. 视觉适配：Flex/Grid + 百分比/vw/vh 进行响应式布局，配合媒体查询适配横竖屏，图片通过 `srcset/sizes`  或 `<picture>`  标签自动加载对应分辨率，通过 DPR 解决 1px 的问题，100%还原设计稿
  2. 资源适配：针对 400M+ 视频卡顿、兼容性差的痛点，推动 SRE 建立统一的媒体处理服务，上传即自动压缩转码，同时封装通用 Video/Canvas 组件，在低端机型自动降级为 WebGL 或序列帧播放，彻底修复澎湃官网在部分机型设备播放异常的问题
  3. 架构适配：通过统一的布局引擎抹平 Flexbox 的端侧差异，计算原生坐标（x, y, w, h）驱动原生控件渲染，研发效率大幅提升
  4. 工程适配：在小米落地 TailwindCSS +Figma D2C 的工程化方案，澎湃、字体站等官网共用一套预设插件，无需重复造轮子，AI 生成的样式代码 80% 可直接复用

设计跨端框架：

- 结论（10s）：我认为跨端框架的设计核心为构建一套 UI DSL 到原生绘制指令的高效映射系统
- 落地细节（240s）：我将框架设计拆解为以下四个方面：
  1. 布局渲染：采用"自绘 + 原生"策略，通过统一的布局引擎抹平 Flexbox 的端侧差异，计算原生坐标（x, y, w, h）驱动原生控件渲染，高性能场景（如 AR/游戏）直接开放 Skia/OpenGL 画布接口，实现像素级自绘
  2. 核心引擎：设计 UI 与逻辑隔离的线程模型，主线程只处理跟手动画、手势处理等高频交互和 UI 渲染，后台线程处理业务逻辑、类前端框架渲染和 Reconciliation，避免主线程阻塞
  3. 生态适配：通信机制采用 JSI 或 C++ Host Object 技术。将 Native 方法直接以宿主对象形式注入 JavaScript Runtime，实现 JavaScript 对 Native 能力的同步直接调用，彻底消除通信延时
  4. 工程提效：① 端侧差异隔离：通过「编译时标记 + 运行时适配」，将端侧特有逻辑（如 iOS 权限申请/Android 硬件适配）封装于独立模块，实现核心业务代码零侵入；②构建优化：集成 Tree Shaking + 按需编译，减少跨端包体积
- 我的思考（90s）：回顾跨端技术演进，我的判断是，未来的跨端不再是 Web 的超集，而是 Native 的超集，早期的跨端是在 Native 里执行 JavaScript，现在的跨端是在 JavaScript 里执行 Native，未来趋势是"渲染下沉，逻辑上浮"，让 C++ 承担更多脏活累活，让 JavaScript 回归纯粹的业务逻辑描述，我们本质上不是在模仿浏览器，而是在重写一个更轻量、无历史包袱的原生渲染引擎，从而彻底解决 WebView 时代的性能瓶颈

