React 开发中接口请求的放置逻辑：

* 组件：接口请求置于 `useEffect/useLayoutEffect/componentDidMount/componentDidUpdate` 中，`useEffect` 在组件挂载或依赖数组更新后异步执行，`useLayoutEffect` 在 DOM 更新后同步执行，`componentDidMount` 在组件挂载后执行，`componentDidUpdate` 在组件更新后执行
* 自定义 Hook：复用请求逻辑，将接口请求的通用逻辑（请求参数、加载状态、错误处理、防抖/节流等）封装为 Hook，在多个组件中复用
* 全局状态管理库：适用于多页面/多组件共享请求结果的场景如用户信息和全局配置等，Redux 的 `thunk/saga`、Zustand 的 `action` 本质为抽离异步请求逻辑，交由全局状态管理层控制
* 前端路由：React Router v6 + 的 `loader` 在路由匹配后、组件挂载前预加载当前路由所需数据，`action` 则适配路由提交如表单 POST 请求，保证请求与路由生命周期联动，路由守卫钩子执行接口请求如权限校验接口，拦截路由跳转流程，验证通过后再渲染目标组件
* 应用入口/初始化阶段：适用于应用启动时加载的核心数据如全局配置、用户登录态和权限菜单，在应用或根组件挂载前如 `ReactDOM.createRoot.render` 前执行

多接口依赖下完整数据渲染的提速逻辑：

* 依赖重构：根据后端数据优先级解耦依赖 + 裁剪数据，让后端接口只返回渲染必须数据
* 接口分层：通过 `Promise.all/Promise.allSettled` 全量并行发送无依赖接口请求，待核心依赖接口返回后再发送依赖其的其他接口
* 接口聚合：BFF 层接收到前端单个请求后，并行调用多个依赖的微服务接口，通过缓存或请求池合并同一请求，聚合返回结果给前端
* 预连接/预加载：通过 `<link rel="preconnect">` 提前建立与接口域名的 TCP 连接，通过 `<link rel="preload">` 预加载关键渲染路径资源
* 移除重复请求：通过键值对存储请求状态，重复请求复用同一结果

多页面复用同一接口：

* 请求封装：将同一接口封装为独立的 API 函数，保证请求方法、请求参数、请求头部字段和状态码的一致性，通过Axios/AJAX/Fetch 和请求中间件设置取消重复请求和错误处理逻辑
* 请求缓存：通过键值对存储请求状态，重复请求复用同一结果
* 防抖节流：延迟请求执行，合并短时间内的重复请求，防抖 -> 同一标识的请求触发后，延迟执行，若在指定期间再次触发，重置延迟时间，仅执行最后一次请求；节流 -> 同一标识的请求在指定期间触发一次

避免无效请求：

* 取消请求：客户端主动取消请求，避免服务端处理无效请求
* 移除重复请求
* 多页面复用同一接口

取消请求：

* Axios 通过 `CancelToken` 创建取消令牌，在发送请求时携带，通过调用 `cancel` 取消请求
* XMLHttpRequest 通过调用 `abort` 取消请求
* Fetch 通过 `AbortController` 创建实例信号，在发送请求时携带，当信号触发时通过 `abort` 取消请求

移除重复请求：

* 请求状态缓存池：通过键值对存储请求状态，重复请求复用同一结果
* 取消重复请求
* 防抖节流：延迟请求执行，合并短时间内的重复请求，防抖 -> 同一标识的请求触发后，延迟执行，若在指定期间再次触发，重置延迟时间，仅执行最后一次请求；节流 -> 同一标识的请求在指定期间触发一次
* 版本号/Token 去重：为各个请求生成唯一版本号或 Token，通过版本更新取消旧请求，执行新请求
* 前后端协同去重：前端前置去重，服务端为各个幂等请求分配唯一标识，接收到请求后根据标识判断请求是否处理，若未处理则执行业务逻辑并记录标识状态，否则直接返回先前的处理结果

分页时后请求先响应导致数据覆盖，确保显示最后选中页的方法：无论响应顺序如何，只处理用户最后一次请求的响应数据

* 切换页面时主动取消上一次未完成的请求
* 各个请求生成唯一标识，前端存储最新请求标识，返回响应时验证标识有效性，当响应标识与存储的最新标识匹配时才处理响应，否则直接忽略


