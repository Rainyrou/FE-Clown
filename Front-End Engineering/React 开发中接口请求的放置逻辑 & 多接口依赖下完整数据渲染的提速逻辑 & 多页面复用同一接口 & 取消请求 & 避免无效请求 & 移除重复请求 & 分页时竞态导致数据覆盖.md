React 开发中接口请求的放置逻辑：

* 组件：接口请求置于 `useEffect/useLayoutEffect/componentDidMount/componentDidUpdate` 中，`useEffect` 在组件挂载或依赖数组变化后异步执行，`useLayoutEffect` 在 DOM 更新后同步执行，`componentDidMount/componentDidUpdate` 在组件挂载/更新后执行
* 自定义 Hook：将接口请求的通用逻辑（请求参数、加载状态、错误处理、取消请求、防抖/节流等）封装为 Hook，在多组件中复用
* 全局状态管理库：多组件/多页面复用请求结果如用户信息、全局配置和权限菜单等，Redux 的 `thunk/saga`、Zustand 的 `action` 封装异步请求逻辑，由全局状态控制
* 前端路由：React Router v6 + 的 `loader` 方法在路由匹配后、组件挂载前预加载当前路由所需数据，`action` 方法适配路由提交如 POST 表单请求，路由守卫钩子执行接口请求并拦截路由，校验成功后渲染组件

多接口依赖下完整数据渲染的提速逻辑：

* 依赖重构：根据后端数据优先级解耦依赖 + 裁剪数据，让后端接口只返回渲染必须数据
* 接口分层：通过 `Promise.all/Promise.allSettled` 全量并行发送无依赖接口请求，待核心依赖接口返回后再发送依赖其的其他接口
* 接口聚合：BFF 层接收到前端单个请求后，并行调用多个依赖的微服务接口，通过请求状态缓存池移除重复请求，聚合多接口响应并将结果返回给前端
* 预连接/预加载：通过 `preconnect` 提前建立与域名的 TCP 连接，通过 `preload` 预加载关键渲染路径资源

多页面复用同一接口：

* 自定义 Hook：将接口请求的通用逻辑（请求参数、加载状态、错误处理、取消请求、防抖/节流等）封装为 Hook，在多组件中复用
* 请求状态缓存池：通过键值对存储请求状态，重复请求则复用同一结果
* 防抖节流：延迟请求执行，合并短时间内的重复请求，防抖 -> 同一标识的请求触发后，延迟执行，若在指定期间再次触发，重置延迟时间，仅执行最后一次请求；节流 -> 同一标识的请求在指定期间触发一次

避免无效请求：

* 取消请求
* 移除重复请求
* 多组件/多页面复用请求结果

取消请求：

* Axios 通过 `CancelToken` 创建取消令牌，在发送请求时携带，通过调用 `cancel` 取消请求
* XMLHttpRequest 通过调用 `abort` 取消请求
* Fetch 通过 `AbortController` 创建实例信号，在发送请求时携带，当信号触发时通过 `abort` 取消请求

移除重复请求：

* 请求状态缓存池：通过键值对存储请求状态，重复请求则复用同一结果
* 取消重复请求
* 防抖节流：延迟请求执行，合并短时间内的重复请求，防抖 -> 同一标识的请求触发后，延迟执行，若在指定期间再次触发，重置延迟时间，仅执行最后一次请求；节流 -> 同一标识的请求在指定期间触发一次
* 版本号去重：各个请求生成版本号，前端存储最新版本号，返回响应时校验版本号有效性，确保只有最新请求的响应更新数据
* 前后端协同去重：前端前置去重，服务端为各个幂等请求分配唯一标识，接收到请求后根据标识判断请求是否处理，若未处理则执行业务逻辑并记录标识状态，否则直接返回先前的处理结果

分页时竞态导致数据覆盖：

* 竞态为发送的请求和返回的响应顺序不一一对应（后发先返）导致旧请求结果覆盖新请求结果
* 切换页面即在发送新请求时取消旧请求
* 各个请求生成版本号，前端存储最新版本号，返回响应时校验版本号有效性，确保只有最新请求的响应更新数据


