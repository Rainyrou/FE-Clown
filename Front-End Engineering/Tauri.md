Tauri 用于为桌面和移动平台构建微快二进制文件的框架，开发人员可集成任何编译为 HTML、CSS 和 JavaScript 的前端框架，同时在需要时以 Rust、Swift 和 Kotlin 等作为后端

Tauri 直接使用 WRY 和  TAO 调用操作系统，前端通过 WebView 构建 UI 并与后端进行通信，抛弃 Electron 内置 Chromium 渲染引擎和 Node.js 环境，打包体积相对更小，后端核心为 Rust， Rust 库规模远不及 npm，Rust 社区也远比 JavaScript 社区小，互联网上关于 Rust 的资料较少，但这也意味着根据所要构建的内容，我们甚至可能根本无需编写大量 Rust 代码

![[Pasted image 20241105151556.png]]

每个 Tauri 应用程序均有一个 Core 进程，其充当应用程序的入口且是唯一对操作系统拥有全局访问权限的组件，Core 进程通过该访问权限来创建和管理应用程序窗口、系统托盘菜单和通知，Tauri 实现必要的跨平台抽象来简化上述操作，其通过 Core 进程路由全局进程间通信和管理全局状态，允许在一个中心位置拦截和操作 IPC，进行数据库连接，易于在 WebView 间同步状态且避免业务敏感数据被前端越权访问，尽量将业务逻辑推至 Core 进程，以保持较小的攻击面，Rust 的所有权概念保证内存安全和出色性能，而 Core 进程不呈现 UI 本身，其启动操作系统提供的 WebView 库之 WebView 进程，WebView 库不打包到最终的构建产物中，而在运行时动态链接，从而减少打包体积

![[Pasted image 20241105152814.png]]

Tauri 采用基于消息队列的异步双向消息传递通道，消息传递通道比共享内存或直接函数访问更安全，因为接收方可根据需要自行拒绝或抛弃请求，如 Core 进程确定某请求为恶意的，它直接抛弃这些请求且永不执行相应函数

事件为即发即弃的单向 IPC 消息，由前端和  Core 进程发起，用于传递生命周期事件和状态管理

![[Pasted image 20241105154107.png]]

Tauri 在 IPC 消息上提供一个类似外部函数接口的抽象，`invoke` API类似浏览器的 `fetch`，允许前端调用 Rust 函数、传递参数和接收响应，此机制在后台使用类似 JSON-RPC 的协议来序列化请求和响应

由于命令仍在后台使用消息传递，因此它们不会像真正的 FFI 接口那样存在相同的安全隐患

![[Pasted image 20241105154357.png]]
参考：[Tauri 2.0 | Tauri](https://v2.tauri.app/)