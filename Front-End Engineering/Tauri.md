Tauri 为桌面和移动平台创建微快二进制文件，集成任何编译为 HTML、CSS 和 JavaScript 的前端框架，以 Rust、Swift 和 Kotlin 等为后端，其通过 WRY 和 TAO 调用操作系统，前端通过 WebView 构建 UI 并与后端通信，抛弃 Electron 内置 Chromium 渲染引擎和 Node.js 环境，打包体积相对更小

![[Pasted image 20241105151556.png]]

各个 Tauri 应用均有一个 Core 进程，其作为应用程序入口且为唯一对操作系统有全局访问权限的组件，Core 进程通过该访问权限创建和管理应用程序窗口、系统托盘菜单和通知，Tauri 通过跨平台抽象简化上述操作，其通过 Core 进程路由全局进程间通信和管理全局状态，允许在一个中心位置拦截和操作 IPC，进行数据库连接，易于在 WebView 间同步状态且避免业务敏感数据被前端越权访问，将业务逻辑推至 Core 进程以保持较小的攻击面，Rust 的所有权概念保证内存安全和出色性能，而 Core 进程不呈现 UI 本身，其启动操作系统提供的 WebView 库之 WebView 进程，WebView 库不被打包至最终的构建产物中，而在运行时动态链接，减少打包体积

![[Pasted image 20241105152814.png]]

Tauri 采用基于消息队列的异步双向消息传递通道，消息传递通道比共享内存或直接函数访问更安全，因为接收方可根据所需自行拒绝或抛弃请求如 Core 进程确定某请求为恶意的，其直接抛弃这些请求且永不执行相应函数

事件为即发即弃的单向 IPC 消息，由前端和  Core 进程发起，用于传递生命周期事件和状态管理

![[Pasted image 20241105154107.png]]

Tauri 在 IPC 消息上提供类似外部函数接口的抽象，`invoke` API 类似浏览器的 `fetch`，允许前端调用 Rust 函数、传递参数和接收响应，此机制在后台通过类似 JSON-RPC 的协议序列化请求和响应

由于命令仍在后台使用消息传递，因此其不像 FFI 接口那样存在相同的安全隐患

![[Pasted image 20241105154357.png]]
参考：[Tauri 2.0 | Tauri](https://v2.tauri.app/)
