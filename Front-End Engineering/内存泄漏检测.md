内存泄漏为本应被垃圾回收的 JavaScript 对象仍被引用如全局变量（严格模式禁止隐式全局变量 + ESLint 配置 `no-undef` 判断未声明全局变量 + 通过 `WeakMap` 或 `WeakSet` 弱引用临时数据 + 手动移除） + 闭包引用（手动移除） + 未移除的事件监听器和定时器（组件销毁时移除） + 第三方库实例（手动移除） + 未设置上限或移除策略而累积的缓存（LRU 算法限制缓存大小） + console.log（手动移除）

- 堆快照对比：生成初始状态的堆快照，执行业务逻辑后生成当前状态的堆快照，强制 GC 后对比，若 GC 后仍存在大量无用JavaScript对象，则判断为内存泄漏
- 内存分配追踪：开启内存分配追踪后执行业务逻辑，记录所有JavaScript对象的调用栈，若某段代码被反复分配内存且未被 GC 回收，其调用栈对应的代码即为内存泄漏源头
- 内存分配时间线：观察时间线上的内存分配情况，正常为内存分配→垃圾回收的波动稳定状态，若JavaScript对象分配密集且内存曲线持续上升，则判断为内存泄漏
- Performance 面板：录制执行业务逻辑的过程，观察堆内存曲线 + GC 事件，若内存曲线持续上升且 GC 事件频繁触发但垃圾回收效果较差，则判断为内存泄漏
- 源码断点调试：在JavaScript 对象创建/销毁、事件监听器和定时器绑定/移除等代码处设置 debugger，通过调用堆栈判断是否有不该存在的引用，辅助定位内存泄漏问题
