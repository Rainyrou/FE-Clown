多页面通信方式：

* postMessage + BroadcastChannel/SharedWorker
* localStorage/sessionStorage + storage 事件监听
* IndexedDB + change 事件监听
* Cookie + 轮询

多标签页轮询同步停止：通过 `BroadcastChannel` 跨标签页通信，任意标签页接收到有效响应后发送停止轮询信号，其他标签页接收到信号后移除定时器并将全局轮询状态标记为停止，执行轮询前判断该状态以避免无效请求

无交互 5 分钟后重新登录：通过 `BroadcastChannel` 跨标签页通信监听鼠标键盘等用户交互事件，任意标签页触发交互后发送活跃信号，其他标签页接收到信号后重置计时器并记录最后活跃时间，前端请求携带 Access Token 以更新后端存储的最后活跃时间，无交互 4 分 30 秒展示即将登出文案，无交互5分钟移除 Access Token 并跳转至登录页，用户重新登录认证后生成新  Access Token 和 Refresh Token，恢复登出前的页面上下文

用户操作下禁止移除多标签页：用户在指定时间内触发主动交互事件而非被动交互事件，根据活跃标识判断用户状态，通过 `BroadcastChannel` 跨标签页通信以同步状态，全局拦截 `beforeunload` 事件/关闭快捷键/右键关闭菜单/`window.close` 以免浏览器移除标签页，通过 `debugger` 语句 + 定时器触发禁止断点调试，通过 `Object.freeze` 禁止用户修改活跃标识

多标签页存在的问题：

* 各个标签页有独立的渲染进程，单个标签页的用户交互无法自动同步至其他标签页
* 定时器 `setTimeout` 和 `setInterval` 存在计时误差，同时浏览器无法保证回调函数与屏幕刷新同步
* 多标签页同时展示即将登出文案 + 表单数据跨标签页丢失 + 恢复登出前上下文的路径冲突（多标签页分别访问不同页面，同时因为未交互而登出，重新登录后同时恢复导致路由冲突）
* 多标签页并行发送请求导致心跳风暴

| 维度   | MessageChannel                                                               | BroadcastChannel                   |
| ---- | ---------------------------------------------------------------------------- | ---------------------------------- |
| 通信范式 | 双向点对点（专用管道）                                                                  | 单向广播式（公共频道）                        |
| 通信范围 | 任意跨上下文（通过 postMessage 跨域）                                                    | 同源上下文（多标签页 /Iframe）                |
| 传输方式 | 结构化克隆 + Transferable（零拷贝）                                                    | 结构化克隆                              |
| 生命周期 | 手动关闭                                                                         | 自动关闭                               |
| 性能开销 | 较小（维护管道）                                                                     | 较大（维护订阅列表）                         |
| 使用场景 | 主线程与 Web Worker 数据交互（大数据计算/音视频处理）/父页面与跨域 Iframe 通信（通过端口管道替代全局 popostMessage） | 多标签页状态同步/同源 Iframe 集群的全局通知/全链路数据分发 |
