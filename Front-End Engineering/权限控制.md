###### 越权访问

权限控制是为了将用户对系统操作控制在一个合法范围内，用户可以是人也可以是其他系统，若操作不在合法范围内，就会发生越权访问行为，从而造成严重的安全问题，被 OWASP 列为 Web 应用十大安全隐患的第二名
简单地说，垂直越权是指访问了原本无权访问的 API，而水平越权则是指访问到了原本无权访问的数据
垂直越权：用户通过非法手段使自己的可操作范围提升，如现在有个系统，它的普通用户页面为 `xxx.com/user` , 管理员页面为 `xxx.com/manager`，但后台管理系统没用做权限控制，我们便可以在登录后携带普通用户的令牌直接跳转到管理员页面，去做一些不可描述的事情

![[Pasted image 20240506140019.png]]

水平越权：服务端由于设计漏洞没有判断数据访问权限所造成的越权行为如现在有个系统，我们登录查看用户 id 为 1 的详情页 `xxx.com/user/1` ，我们将 URL 的 1 改为 2，由于后端没有判断我是否可以查看 id 为 2 的用户，就把数据返回给我

![[Pasted image 20240506143432.png]]

鉴权：用户进行操作时，权限系统先判断用户是否有进行此操作的权限
权限控制：判断请求发起者在某些条件下是否对请求数据具备操作 API  的能力

RBAC 基于角色的访问控制：通过分配用户到特定角色并为这些角色定义访问权限来控制权限，一个角色代表一组权限集合，用户通过赋予角色来获取这些权限即 RBAC0，RBAC1 引入角色继承的概念，角色 B 继承 A，则当分配用户到角色 B 时，其具备角色 A 的权限，RBAC2 引入角色互斥的概念如运动员不能是裁判的业务场景，RBAC3 则结合了 RBAC1 和 RBAC2，同时拥有角色继承和角色互斥的功能

为便于用户操作，RBAC 衍生出权限组和用户组的实体模型，权限组为一组 API 的集合如用户操作权限组包含对用户数据的增删查改操作，使用权限组时，角色不与 API 绑定，而是与权限组绑定。用户组为将某一类用户分组，用户组与角色绑定，而非用户与角色绑定，即用户只要加入该组则具备相应的操作权限

![[Pasted image 20240506144010.png]]

ABAC 基于属性的访问控制：现在的 AWS、腾讯云、阿里云和曾经的 k8S 等通过 ABAC 控制 Laas 和 Paas 资源权限。在复杂的业务场景下，RBAC 显得有些力不从心，如用户只能在白天访问系统，用户只能在大陆访问系统，用户只能在内网修改订单，在外网只有查看权限，用户对 2024 年 5 月 6 日前创建的订单具有操作权限，用户在公司内网可访问所有数据，而在外网只能访问公开资源。RBAC 只描述用户可以进行哪些操作，但操作的条件及操作的数据，模型本身是没有这些限制的，这是由于其模型能力不足所导致的，但这恰恰是 ABAC 的优势，ABAC 的思想基于用户、要访问的数据之属性及各种环境因素动态计算用户是否有操作的权限。ABAC 擅长控制垂直越权，但即便其具备一定的控制水平越权的能力，也不要妄想用其控制所有水平越权

![[Pasted image 20240506145417.png]]

前端权限控制并非真正的权限控制，而只是提升用户体验，前端做的所谓权限控制，是因为不同用户权限不同，有些路由或页面或页面某些板块没有权限时，根据后端返回的权限列表去控制这部分内容的显示隐藏及提交功能，并且后端根据前端请求或提交数据时传递的参数或 token 检查用户权限，来决定是否返回数据或修改数据库，真正的权限是后端在控制，前端只是为了提高用户体验。这里的页面渲染即初始化，开始编译时，`v-if` 控制是否生成对应 DOM，`v-show` 通过 CSS 控制显示隐藏，真实 DOM 一直存在，可在 `setup` 函数中修改 `data` 状态来控制显示隐藏

权限控制在后台管理系统中是极其重要的环节，通过配置调整用户拥有的模块或页面权限，让用户只能访问到对应权限的页面，即哪些页对所有用户开放，哪些页面只能登录后访问，哪些页面需要普通成员/管理员/超级管理员权限才能访问

易于拓展 + 可维护性

1. 权限控制：精确到按钮甚至某一文案的权限
2. 用户登录或刷新后请求权限接口，分为 `menuList` 和 `codeList`
3. `menuList` 返回的参数较多，用于动态路由等，包含当前路由是否具有权限，无权限菜单接口直接不返回
4. `codeList` 是字符串形式如 `"ec#app.store.stylize.shareSetting"` ， 当然，按钮权限可同时满足多个条件控制
5. 使用 localhost 做权限缓存
6. 在页面渲染时判断页面路径、按钮或某字段是否展示

对权限控制而言，前端代码校验可通过数据造假验证，安全性较低，后端应根据权限严格控制接口调用，首先展示无需登录的默认页面如注册/登录页，登录时调用接口拿到后端返回的权限数据，将数据注入到系统中，系统拿到权限数据后开始展现页面内容并生成导航，最终生成当前用户权限所对应的系统

后端一次返回权限码列表 `permissionCodeList`，通过 Vuex/Pinia 全局存储

```js
import { defineStore } from 'pinia';
export const usePermissionStore = defineStore({
    state: () => ({
        permissionCodeList: [],
    }),
    getters: {
        getPermissionCodeList(){
      		return this.permissionCodeList;
    	},
    },
    actions: {
        setPermissionCodeList(codeList) {
            this.permissionCodeList = codeList;
        },
        async changePermissionCodeList() {
            const codeList = await getPermissionCodeList();
            this.setPermissionCodeList(codeList);
        }
    }
})
```

###### 按钮级别

```js
export function usePermission() {
    function hasPermission(value, def = true) {
        if (!value) return def;
        const allCodeList = permissionStore.getPermCodeList;
        if (!isArray(value)) return allCodeList.includes(value);
        return (intersection(value, allCodeList)).length > 0;
        return true;
    }
}
```


```js
import { usePermission } from '/@/hooks/web/usePermission';

function isAuth(el, binding) {
  const { hasPermission } = usePermission();
  const value = binding.value;
  if (!value) return;
  if (!hasPermission(value)) el.parentNode?.removeChild(el);
}

const mounted = (el, binding) => isAuth(el, binding);
export function setupPermissionDirective(app) {
  app.directive("auth", {
    mounted: (el, binding) => {
        const value = binding.value
        if (!value) return
        if (!hasPermission(value)) removeEl(el)
    },
    updated(el, binding) {
        if (binding.value === binding.oldValue) return
        let oldHasPermission = hasPermission(binding.oldValue)
        let newHasPermission = hasPermission(binding.value)
        if (oldHasPermission === newHasPermission) return
        if (newHasPermission) addEl(el)
        else removeEl(el)
    },
    const hasPermission = (value) => return [1, 2, 3].includes(value)
	const removeEl = (el) => {
	    el._parentNode = el.parentNode
	    el._placeholderNode = document.createComment("auth")
	    el.parentNode?.replaceChild(el._placeholderNode, el)
	}
	const addEl = (el) => el._parentNode?.replaceChild(el, el._placeholderNode)
	})
}
```


```js
<a-button v-auth="'1000'" type="primary" class="mx-4"> 拥有code ['1000']权限可见 </a-button>
```

###### 登录 & 角色 & 内容权限控制

1. 登录权限控制：定义包含所有无需登录即可查看的页面路由之 `invisible` 数组，路由名称映射到 `invisibleMap` 数组上，通过 `beforeEach` 路由守卫拦截判断。此外在路由对象中添加 `meta` 也可实现，登录页面无需设置`meta.need_login` 属性，列表页面设置 `meta.need_login` 属性，同样通过 `beforeEach` 路由守卫拦截判断
2. 角色权限控制：用户 -> 角色 -> 菜单 -> 操作（1：n），后端权限数据结构不应与前端路由结构耦合，否则在前端页面结构修改或多页面共用同一权限按钮等场景下维护困难，每一个页面、每一个操作按钮均用不同 id 定义权限，且后端返回的权限 id 放到一级数组即可，无需多级结构，前端只需知道用户具有哪些权限，其他的自定义，只有在权限管理页面才需返回特定数据结构来自定义修改权限

后端返回的权限结构：

```js
{
   "home": {
     "id": "100",
     "name": "home",
     "desc": "首页",
     "value": true,
     "children": [],
   }
 }
```

`id` 为页面唯一标识，`name` 与前端路由页面对象的 `name` 值相对应，`desc` 为菜单上展示的名称，`value` 为页面显示隐藏，`children` 数组为此页面的二级页面数组。在此结构中，前端判断 `value` 决定该页面是否有权限展示，若一级页面`value` 为 `false`，则二级页面无权展示。前端递归遍历后端返回的结构，判断 `value` 为 `false` 时，将相应路由页面过滤掉

```js
// 遍历权限配置数组或对象
function filterRouter(arr, obj, type) {
  if (Array.isArray(obj))
    obj.forEach((item) => handleRouterItem(arr, item, type));
  else for (const item in obj) handleRouterItem(arr, obj[item], type);
}

function handleRouterItem(arr, item, type) {
  if (item.value === false) {
	// 从数组中移除对应路由
    if (type === "menu") assistance(arr, routerMap[item.name]);
    // 在路由元数据中标记权限如 `hasRoleAuth` 为 `false`
    else assistanceRouter(arr, routerMap[item.name]);
  } else if (item.children && item.children.length) {
    filterRouter(arr, item.children, type);
  }
}

function assistanceRouter(arr, name, obj) {
  for (let i = 0; i < arr.length; ++i) {
    if (arr[i].name === name) {
      Vue.prototype.$set(arr[i].meta, "hasRoleAuth", false);
      return true;
    } else if (
      arr[i].children &&
      arr[i].children.length &&
      assistanceRouter(arr[i].children, name, arr[i])
    )
      return;
  }
}

// 过滤无权限的页面用于生成菜单
function assistance(arr, name, obj) {
  for (let i = 0; i < arr.length; ++i) {
    if (arr[i].name === name) {
      arr.splice(i, 1);
      return true;
    } else if (
      arr[i].children &&
      arr[i].children.length &&
      assistance(arr[i].children, name, arr[i])
    )
      return;
  }
}

export const rolePermission = () => {
  filterRouter(router, roleRouter);
  router.addRoutes(router);
};
```

3. 内容权限控制
4. 退出登录/切换用户

```js
import Router from 'vue-router';
import router from '@/router';
import store from '@/store/index.js';
import invisible from '@/router/invisible';

export const resetRouter = () => {
  let newRouter = new Router({
    routes: [...invisible],
  });
  router.matcher = newRouter.matcher;
  store.commit('CLEAR_ROLE_AUTH');
};
```
