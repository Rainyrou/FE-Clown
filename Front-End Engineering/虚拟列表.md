虚拟列表只渲染可视区域内的列表项，而不是渲染整个列表，从而显著提升长列表性能和用户体验，如 React `react-virtualized` 和 Vue `vue-virtual-scroll-list`

- 不使用虚拟滚动时，若一次性渲染 10 万数据，页面初始加载时间超过数秒，造成严重卡顿
* 视口大小：1920x1080 px
* 列表项高度：150 px
* 初始渲染数量：1080 / 150 ≈ 7.2
- 初始加载列表项：只加载可视区域上下方各两行
- 加载时间：虚拟列表初始化加载的数据量大约为 0.011%（11 / 100000），初始加载时间可从几秒降低到几十毫秒内

###### 原理

1. 可视区域渲染： 只渲染可视区域内的列表项，若列表有十万项，用户一次只能看到十几项，则只有它们被实际渲染成 DOM 元素，即限制在 DOM 中实际渲染的元素数量以优化性能
2. 滚动处理： 当用户滚动列表时，组件计算当前滚动位置并更新可视区域内的列表项，即移除旧的列表项 DOM 元素，并创建新的列表项 DOM 元素
3. 位置计算：每个列表项的高度可以是定高 or 不定高，其用于决定在当前的滚动位置渲染哪些元素

###### 实现细节

1. 组件结构 & 样式：组件最外层 `.virtuallist-container` 作为容器控制滚动，`.virtuallist-content` 承载列表，`.virtuallist-list` 作为实际的列表项容器，`.virtuallist-list-item` 作为列表项，`overflow: auto;` 实现滚动效果，其余样式保证列表和列表项的基本布局
2. 状态管理： `props` 接收外部传入的数据源 `dataSource` 和加载状态 `loading`。使用 `ref` 和 `reactive` API 响应式 `state` 来存储容器高度、列表高度、当前渲染的起始索引、最大渲染数量和上次计算长度，`computed` 计算属性来动态计算结束索引 `endIndex`、当前渲染的列表 `renderList` 和滚动偏移量 `offsetDis`
3. 初始化和位置计算 `initPosition`：在数据源更新时，计算每个列表项的预测位置和高度并存储到 `positions` 数组中，`positions` 数组包含列表项元素索引、顶部位置、底部位置、列表项元素高度、自身对比高度差（以判断是否需更新），设置实际位置 `setPosition`：使用 `getBoundingClientRect` 获取当前渲染列表项的实际高度，并与预测高度进行比较，调整 `positions` 中相应列表项的高度和底部位置信息
4. 滚动处理 `handleScroll`：通过节流函数减少滚动事件的处理频率，二分查找根据滚动位置动态计算当前应渲染的起始索引
5. 渲染列表项 `renderList`：根据计算出的起始和结束索引，从 `dataSource` 中 slice 需渲染的列表片段，通过 `v-for` 指令动态渲染列表项，并通过插槽 `slot` 传递列表项数据，允许自定义列表项内容

###### 计算列表项高度 & 最大容纳量

item 高度 + container 高度 => 最大容纳量 + startIndex => endIndex => renderList
item 高度 + dataSource 数据源 => 列表高度 + 滚动偏移量
item 高度 + scrollTop => startIndex

定高虚拟列表的实现要求用户传入固定的 item 高度，而不定高虚拟列表的实现无需传入固定的 item 高度，而是传入预测的 item 高度，我们保证预测的 item 高度尽可能比真实的每一个 item 的高度小或接近所有 item 高度的平均值。虚拟列表内部需要根据预测的 item 高度来计算整个虚拟列表的最大容纳量，若预测 item 高度过大，则会出现真实 item 渲染到视图上时出现留白的情况，而预测 item 高度比真实 item 高度都小，就能保证预测计算出的最大容纳量大于真实 item 渲染列表的最大容纳量，这样就不会出现留白的情况

![预测高度设置问题.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca4613942720489fb4765525a255630d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=7147&h=3286&s=1072591&e=png&b=f9fafb)

###### 计算列表高度 & 滚动偏移量

定高虚拟列表的实现直接无脑使用数据源长度，不定高虚拟列表需要手动获取 DOM 再计算，我们直接通过列表的 DOM 信息即 `state.listHeight` 获取高度，但滚动时的偏移量需根据每滚动出去一项再计算，`state.listHeight` 不能解决这一问题，因此引入新变量 `positions`，用于存储每个 item 的信息，包含列表项元素索引、顶部位置、底部位置、列表项元素高度、自身对比高度差（以判断是否需更新）

列表高度 => `positions` 最后一项 item 的 `bottom` 值
滚动偏移量 => 当 `scrollTop` >= 某一 item 的 `bottom` 值时，表明该 item 已滚动出可视区域

###### 挂载真实 DOM 列表挂载 & 更新 item 信息

上面的 `positions` 暂时以预测高度替代，当 DOM 挂载后我们需要获取 DOM 的真实高度来更新 item，通过 `nextTick` 保证基于最新的响应式数据更新 DOM。我们通过 `ref` 获取列表 `list` 里的 `children` 拿到可视区域内的每一个 item，同时在 template 模板里给 item 添加 `id` 以保证可视区域内的 item 与 `positions` 里的 item 一一对应，具体来说，遍历 `children`，对于每一个 DOM item，通过其 `id` 属性找到 `positions` 中对应的 item，更新该 item 信息，`dHeight` 字段在这里发挥作用，它代表着当前 item 高度的差值，即初始化时我们使用的预测高度与真实 item 高度可能有偏差，若存在差值则需更新 item 的高度和 `bottom` 值，但 `top` 值仍未更新，且 `positions` 还有剩余 item 未更新完毕，如数据集长度为 20，而可视区域内渲染的 item 数量为 10，则剩余的 10 个 item 位置信息没有更新，由于可视区域内 item 的 height 改变，导致剩余的 item 位置信息错乱，因此还有考虑更新剩余的 item，也就是说我们遍历起始位置到 `positions` 末尾进行更新，注意起始位置为渲染在可视化区域内所有 item 项中的第一项，而非  `positions[0]`，因为我们还要考虑滚动操作，更新的范围是 start item ~ end item，我们通过 `id` 属性找到 `positions` 对应的 start item
![更新items范围.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02e0ee94dc4c42d9808cba458e4263a3~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=629&h=841&s=69653&e=png&b=f9fafb)
![更新items范围.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02e0ee94dc4c42d9808cba458e4263a3~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=629&h=841&s=69653&e=png&b=f9fafb)


实际上第一项的 `top` 值为 0，`bottom` 值在上一轮更新过了，因此从第二项开始遍历，但需要用到第一项的 `dHeight` 来更新第二项的 bottom 值：

![更新bottom值.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2207ca33dc444038cc420cb0633b302~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1454&h=831&s=159389&e=png&b=f9fafb)

1. item2.top = item1.bottom
2. item2.bottom = item2.bottom - item1.dHeight

每轮循环我们做三件事：

1. 利用上一个 item 的 `bottom` 值，更新当前 item 的 `top` 值
2. 利用 `dHeight` 累计值，更新当前 item 的 `bottom` 值
3. 将当前 item 的 `dHeight` 进行累计，再重置为 0，更新后不再存在高度差

更新后的 `positions` 已包含真实 item 的信息，我们可以在 `setPosition` 大胆设置 list 的高度

![offset偏移量.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6274efb00765497788c9b9bf4de06486~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=791&h=595&s=56897&e=png&b=f9fafb)

###### 计算 startIndex

`startIndex` 所对应的 item => 遍历 `positions` 数组找到第一个 item.bottom >= scrollTop 的 item
在 `positions` 数组中 item.bottom 递增，通过二分查找来找到对应的 `startIndex`，若找到则用找到的索引 + 1 作为 `startIndex`，因为找到的 item.bottom 等于 `scrollTop` ，即该 item 已滚出，但也可能存在找不到的情况，说明 `startIndex` 的 item 已滚出一部分，这时我们取其 `right` 的索引位置作为 `startIndex`

###### 触底加载更多

定高的虚拟列表实现中通过计算 `endIndex` 时处理触底操作，而在不定高的虚拟列表实现中我们是在滚动事件中处理，即 scrollHeight、clientHeight、scrollTop 比较。一旦更新数据源，我们通过 `watch` 和 `nextTick` 来重新执行之前设置 item 信息的一系列操作，只有新增数据需要进行初始化，之前 `positions` 里已保存的信息无需重新初始化，也就是说我们每一次执行 `initPosition` 后需保存当前的 `positions.length`，第二次调用时直接跳过这些项即可，且存在之前项的话，新增数据的每一项 `top` 和 `bottom` 信息均从之前数据源的最后一项开始进行累加，而我们初始化时的 `state.preLen` 就保存上一次的 length，那大功告成！！！

###### 计算加载时间

1. 数据获取时间：使用 Axios & Fetch API & AJAX 从服务端获取数据，通过 Chrome DevTools 的网络面板监测数据请求的响应时间和数据下载时间
2. 数据处理时间：获取原始数据后，对数据进行解析、排序和筛选等操作，使用 `performance.now` 在通过在数据处理开始和结束时记录时间戳来计算
3. 初始渲染时间：使用 Chrome 的 Performance tab 来详细查看渲染过程中的各项数据指标

###### 滚动时闪烁白屏

1. 首先确保数据加载不是导致白屏的主要原因，使用 Chrome DevTools 的网络面板监控数据请求，检查请求的发送、响应和完成时间，查看是否有异常延迟，通过 Layers 和 Paint Profiler 工具分析页面布局和绘制，检查是否有过多的重绘回流情况，通过 Performance 工具查看资源加载时间和执行顺序，分析这些资源是否阻塞关键渲染路径，同时录制页面加载和快速滚动期间的性能情况，查看详细的时间线和火焰图，特别注意 JavaScript 执行和渲染时间及可能的布局重新计算，在 JavaScript 分析器中检查哪些函数占用大量时间，若发现特定的数据处理或 DOM 操作代码执行时间过长，这可能是造成白屏的原因
2. 在列表的顶部和底部使用占位符，以保证滚动条的正确行为和显示
3. 监测滚动速度并动态调整可视区域大小，在快速滚动时增大预渲染区域，减少窗口进入未渲染区域的可能性
4. 在可视区域上下方提前多渲染额外列表项，以便当用户滚动到新位置时，所需列表项已准备就绪，同时延迟卸载已移出可视区域的列表项，如此一来若用户快速滚回之前的位置，这些列表项无需重新渲染
5. 缓存和复用 DOM 元素而非在滚出可视区域时将对应元素销毁，更新其内容以匹配新的列表项数据
6. 在滚动事件中使用 `requestAnimationFrame` 确保 DOM 更新操作在浏览器的下一帧渲染前完成
7. 现代浏览器支持将网页元素分层，并可对各层单独进行合成，通过 CSS 的 `transform` 和 `opacity` 属性触发硬件加速，这些属性通常不会引起回流，同时使用 `will-change` 或 `transform: translateZ(0)` 将每个列表项或列表容器设置为单独的层，从而加快页面元素渲染更新
8. 前端监控 SDK 埋点监控用户的滚动方向和速度，据此动态调整数据的预加载策略如提前从服务端请求数据

###### 实现搜索功能

1. 数据索引：哈希表实现，每项的搜索关键词或它的一部分指向数据集的列表项，从而减少搜索过程中要遍历的数据量
2. 查询处理：正则表达式和字符串匹配算法如 KMP 和倒排索引解析查询字符串
3. 筛选数据集：数组的 `.filter` 方法或从数据索引中直接获取匹配项的集合
4. 更新虚拟列表：一旦完成筛选，更新虚拟列表以只显示匹配的结果，重新计算渲染窗口和调整滚动位置
5. 性能优化：防抖实现搜索输入

###### 实现选中功能

状态管理：为每个列表项维护一个选中状态，添加 `isSelected` 属性并为其添加点击事件监听器，用于表示该列表项是否被选中，当其被点击时，触发事件处理程序，更新其 `isSelected` 属性。当列表项在可视区域内或其状态变化，检查其 `isSelected` 属性，并据此更新其样式

###### 实际元素高度未达到最小列表项长度

1. 当列表项数量不足以填满整个可视区域时，计算实际列表项的总高度，将此高度值设置为虚拟列表的容器高度，动态调整虚拟列表的容器高度，使之与实际列表项的总高度相匹配，若总高度小于可视区域的高度，容器高度就应限制在该值范围内
2. 条件渲染滚动条即添加逻辑判断当前的列表项总高度与可视化区域高度的大小关系，只在实际需要时显示滚动条，若内容不足以触发滚动则隐藏滚动条如设置 `overflow-y: hidden;`
3. 当列表项数量不足以填满整个可视区域时，使用占位符或提示信息来填充剩余空间，避免视觉上的空洞感，提高用户体验

###### 图片处理

1. 通过计算图片的宽高比动态调整图片大小以适应列表项高度，尽可能保留图片内容
2. 若图片仅作为视觉元素，将其设置为列表项的背景，`background-size: cover;` 用于将背景图片完全覆盖列表项，剪裁掉部分以符合列表项元素大小，`background-size: contain;` 用于将背景图片完整呈现在列表项内，可能留白
3. 在虚拟列表中提供缩略图，用户点击后通过弹窗或全屏展示完整图片

###### 若有错误数据需显示，但不在其显示范围

1. 在数据集中标记可能出现错误的列表项，添加如 `isValid`、`error` 等属性表示错误状态，同时在虚拟列表基于状态的渲染逻辑中添加条件样式，其基于列表项的错误状态动态应用样式即一旦滚动到可视区域则应用对应样式
2. 若相关的错误数据重要，添加按钮让用户可直接跳转定位到出现错误的列表项，即便它们当前不在可视区域内
3. 在虚拟滚动外维护一个错误列表或映射，其从整个数据集中汇总错误信息，通过可视化方式直接给用户提供反馈，让用户可直接跳转定位到出现错误的列表项
