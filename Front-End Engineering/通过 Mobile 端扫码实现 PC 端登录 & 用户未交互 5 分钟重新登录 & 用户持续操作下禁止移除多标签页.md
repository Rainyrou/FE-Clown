通过 Mobile 端扫码实现 PC 端登录，本质为认证状态迁移 + 跨设备授权的机制：

* PC 浏览器向服务端请求登录二维码，服务端接收到请求后，生成全局唯一且有时效性的 UUID 将并其作为 Key，在 Redis 缓存中创建记录并设置 UUID 初始状态为待扫描和相应过期时间，将 UUID 包装为 URL 并生成对应二维码图片，将其返回给 PC 端浏览器
* PC 端浏览器接收到二维码后将其展示给用户并通过与服务端建立 WebSocket 连接以实时获取二维码状态，Mobile 端扫描二维码并解析，获取 UUID 后向服务端发送"已扫描"请求（UUID + AuthToken）
* 服务端接收到请求后验证 UUID + AuthToken 以确认用户身份，根据 UUID 查找 Redis 缓存对应记录，若其为待扫描状态且未过期，更新 UUID 状态为已扫描并关联相关 Mobile 端，PC 端通过 WebSocket 连接获取 UUID 状态为已扫描，重新渲染 UI 并显示"扫描成功"，Mobile 端在请求成功后弹出确认弹窗，显示"即将登录 PC 端"，点击"确认登录"后向服务端发送"确认登录"请求（UUID + AuthToken）
* 服务端接收到请求后，再次验证 UUID + AuthToken，若其为已扫描状态，则为 PC 端浏览器生成新 AuthToken，更新 UUID 状态为已确认并将新 AuthToken 存储于 UUID 记录，返回新 AuthToken 给 PC 端浏览器，PC 端浏览器通过 WebSocket 连接获取 UUID 状态为已确认，接收新 AuthToken 并存储于 Cookie，跳转至已登录页面，后续所有请求均携带该新 AuthToken

实现用户未交互 5 分钟重新登录：监听 `click`、`keydown`（立即响应）、`scroll` 和 `mousemove`（节流响应） 等用户交互事件，前端通过 `BroadcastChannel` 建立跨标签页通信通道，任一标签页触发交互后立即发送活跃广播，所有同源标签页接收后同步重置本地计时器并记录最后活跃时间，发送携带 Access Token 的心跳请求同步更新后端 Redis 存储的最后活跃时间，在无用户交互 4 分 30 秒后弹出即将登出提醒，在无用户交互五分钟或后端 Redis 存储的最后活跃时间与当前时间差 >= 5 分钟时，前端移除本地存储的 Access Token 并强制跳转至登录界面，用户重新登录后，后端重新认证并生成新的  Access Token 和 Refresh Token，更新后端 Redis 存储的最后活跃时间，前端获取新 Access Token 后，恢复登出前的页面

多标签页存在的问题：

* 浏览器各个标签页有独立的渲染进程，单个标签页的用户交互无法自动同步至其他标签页
* 定时器 `setTimeout` 和 `setInterval` 计时偏差，其为宏任务，需等待浏览器所有同步任务及高优先级任务执行完毕才执行，此外其为手动设置，浏览器无法保证回调函数与屏幕刷新同步
* 多标签页同时弹出即将登出提醒 + 表单数据跨标签页丢失 + 恢复登出前的路径冲突（多标签页分别访问不同页面，同时因未交互而登出，重新登录后同时恢复导致路由冲突）
* 多标签页并行发送心跳请求导致心跳风暴

浏览器移除标签页：点击标签页/窗口关闭按钮 + `Alt+F4/Ctrl+W/Cmd+W` + 右键上下文菜单选择关闭 + `window.close`

用户持续操作下禁止移除多标签页：

持续操作即用户在指定时间内触发过主动交互事件而非被动交互事件，根据活跃标识判断用户活跃状态，通过 `BroadcastChannel` 建立跨标签页通信通道以同步状态，全局拦截 `beforeunload` 事件/关闭快捷键/右键关闭菜单/`window.close`，通过 `debugger` 语句 + 定时器循环触发禁止开发者工具断点调试，通过 `Object.freeze` 禁止用户手动修改活跃标识