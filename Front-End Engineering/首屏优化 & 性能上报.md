###### 首屏优化

1. DNS：通过 `dns-prefetch` 预解析 DNS，通过  `preconnect`  提前建立与域名的 TCP 连接

2. HTTP：全链路开启 HTTP2/3，突破 Chrome 6 个 TCP 连接并发限制（火焰图）

3. 静态资源：

- 通过 `preload` 预加载首屏资源，通过  `prefetch`  在浏览器空闲时预加载非首屏资源
- 尽可能在编译阶段确定并通过 CDN 加载，将不频繁更新的资源打包为同一 Bundle 并配置"长缓存 + MD5"哈希，提升资源缓存命中率
- 图片通过 CDN 实现自适应压缩 + 转换为 WebP 格式

4. JavaScript：

- 通过静态分析 Treeshaking 移除无用代码
- 首屏代码阻塞式密集执行，非首屏代码通过动态 `import` 懒加载
- 通过 Worker 线程拆分首屏 JavaScript 长任务
- 对高频触发的首屏交互进行防抖节流处理

5. 接口请求：

- 依赖重构：根据后端数据优先级解耦依赖 + 裁剪数据，让后端接口只返回渲染必须数据
- 接口分层：通过 `Promise.all/Promise.allSettled` 全量并行发送无依赖接口请求，待核心依赖接口返回后再发送依赖其的其他接口
- 接口聚合：BFF 层接收到前端单个请求后，并行调用多个依赖的微服务接口，通过缓存或请求池合并同一请求，聚合返回结果给前端
- 移除重复请求：通过键值对存储请求状态，重复请求复用同一结果

6. 渲染链路：

- 路由渲染优化：通过 SSR/CSR 混合渲染模式，首屏核心内容通过 SSR 直出，非核心内容客户端水合后渲染
- 权限校验前置：首屏权限校验接口在网关或 SSR 阶段完成，避免客户端渲染后再校验导致的白屏
- 骨架屏预渲染：首屏数据未就绪时渲染骨架屏提前初始化 DOM，数据就绪后只需替换首屏内容，减少重绘回流耗时
- 批量 DOM 更新：通过 `DocumentFragment`  批量组装首屏 DOM 节点并一次性插入页面
- 渲染降级兜底：首屏接口超时或失败时，通过缓存或默认数据进行兜底

###### 性能上报

数据采集：

- 环境信息（机型设备、操作系统和浏览器内核） -> 排查问题时定位错误来源
- 性能信息（网络层面和页面层面） -> 发现影响用户体验的性能问题
- 错误信息（未被捕获的全局运行时错误、未被处理的 rejected Promise 和静态资源加载错误） -> 研发及时响应修复问题
- 业务信息（用户行为和页面交互） -> 产品使用情况

网络层面指标：

- 重定向耗时：`redirectEnd - redirectStart`
- DNS 解析耗时：`domainLookupEnd - domainLookupStart`
- TCP 连接耗时：`connectEnd - connectStart`
- SSL 耗时：`connectEnd - secureConnectionStart`
- TTFB（Time To First Byte）网络请求耗时：`responseStart - requestStart`
- 数据传输耗时：`responseEnd - responseStart`
- 资源加载耗时：`loadEventStart - domContentLoadedEventEnd`

![[1708767210268.png]]

![[Pasted image 20240224173357.png]]

页面层面指标：

- FP（First Paint）：页面首次绘制时间 -> Performance
- FCP（First Contentful Paint）：页面首次内容绘制时间 -> Performance
- LCP（Largest Contentful Paint）：页面最大内容绘制时间 -> Performance Insights
- FMP（First Meaningful Paint）：页面首次有意义绘制时间
- DCL（DomContentLoaded）：DOM 内容加载完成时间
- L（onLoad）：页面完全加载的时间
- TTI（Time to Interactive）：页面可交互的时间
- FID（First Input Delay）：用户首次交互到页面响应的时间

自动采集：创建  `PerformanceObserver`  实例，注册回调，监听目标指标，在指标触发时执行回调，接收  `entries`  参数，提取核心数据存储于内存池，批量上报
手动埋点：定义埋点工具函数，在页面加载完成、组件挂载后和销毁前、接口请求、用户交互和浏览器空闲时调用

传输方式：

- 1x1 像素 GIF：创建 `<img>` 元素，将其 `src` 指向分析端点，以性能指标为查询参数，浏览器发送 GET 请求获取该图片，兼容性好，局限于 GET 请求且 URL 长度存在限制，有数据截断风险，无法处理响应

* `navigator.sendBeacon`：POST 异步请求，由浏览器处理，页面销毁时也能发送，局限于 POST 请求且数据大小存在限制，无法自定义请求头部，无法处理响应
* `fetch` + `keepalive: true`：支持 HTTP 所有方法，无数据大小限制，自定义请求头部，处理服务端响应
