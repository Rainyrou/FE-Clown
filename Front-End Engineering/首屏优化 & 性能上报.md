###### 首屏优化

- 结论（10s）：我认为，首屏优化本质为缩短关键渲染路径
- 核心逻辑（60s）：我将优化分为三个维度的竞速：
  1. 链路竞速：全链路开启 HTTP/3 + QUIC 实现 0-RTT 建连，并在 CDN 边缘流式缓存，让首字节时间逼近极限
  2. 资源竞速：内容上，采用 AVIF/WebP 自适应且极致 Tree Shaking；调度上，通过 Priority Hints 将首屏关键资源的加载优先级拉满，非关键资源延迟加载
  3. 执行竞速：架构上采用 Streaming SSR 突破 TTFB 与 FP 的串行死锁，配合骨架屏占位，将 CLS 降至 0
- 落地细节（60s）：在实战中，我重点治理了两个环节：第一，接口聚合与数据治理，在 BFF 层聚合 6 个接口通过 `Promise.all` 并发请求，并根据前端数据优先级解耦依赖 + 裁剪数据，让接口只返回首屏所需数据，同时在 SSR 脱水阶段内联注入，消除客户端二次请求瀑布流。 第二，主线程减负，将不频繁更新的资源打包为同一 Bundle 并配置"长缓存 + MD5 哈希"，提升资源缓存命中率，针对非首屏的长任务逻辑如监控 SDK，我通过 `requestIdleCallback` 或 Web Worker 隔离，并利用 `DocumentFragment` 批量更新 DOM，确保主线程专注于核心 UI 绘制

###### 性能上报

数据采集：

- 环境信息（机型设备、操作系统和浏览器内核） -> 排查问题时定位错误来源
- 性能信息（网络层面和页面层面） -> 发现影响用户体验的性能问题
- 错误信息（未被捕获的全局运行时错误、未被处理的 rejected Promise 和静态资源加载错误） -> 研发及时响应修复问题
- 业务信息（用户行为和页面交互） -> 产品使用情况

网络层面指标：

- 重定向耗时：`redirectEnd - redirectStart`
- DNS 解析耗时：`domainLookupEnd - domainLookupStart`
- TCP 连接耗时：`connectEnd - connectStart`
- SSL 耗时：`connectEnd - secureConnectionStart`
- TTFB（Time To First Byte）网络请求耗时：`responseStart - requestStart`
- 数据传输耗时：`responseEnd - responseStart`
- 资源加载耗时：`loadEventStart - domContentLoadedEventEnd`

![[1708767210268.png]]

![[Pasted image 20240224173357.png]]

页面层面指标：

- FP（First Paint）：页面首次绘制时间 -> Performance
- FCP（First Contentful Paint）：页面首次内容绘制时间 -> Performance
- LCP（Largest Contentful Paint）：页面最大内容绘制时间 -> Performance Insights
- FMP（First Meaningful Paint）：页面首次有意义绘制时间
- DCL（DomContentLoaded）：DOM 内容加载完成时间
- L（onLoad）：页面完全加载的时间
- TTI（Time to Interactive）：页面可交互的时间
- FID（First Input Delay）：用户首次交互到页面响应的时间

自动采集：创建  `PerformanceObserver`  实例，注册回调，监听目标指标，在指标触发时执行回调，接收  `entries`  参数，提取核心数据存储于内存池，批量上报
手动埋点：定义埋点工具函数，在页面加载完成、组件挂载后和销毁前、接口请求、用户交互和浏览器空闲时调用

传输方式：

- 1x1 像素 GIF：创建 `<img>` 元素，将其 `src` 指向分析端点，以性能指标为查询参数，浏览器发送 GET 请求获取该图片，兼容性好，局限于 GET 请求且 URL 长度存在限制，有数据截断风险，无法处理响应

* `navigator.sendBeacon`：POST 异步请求，由浏览器处理，页面销毁时也能发送，局限于 POST 请求且数据大小存在限制，无法自定义请求头部，无法处理响应
* `fetch` + `keepalive: true`：支持 HTTP 所有方法，无数据大小限制，自定义请求头部，处理服务端响应
