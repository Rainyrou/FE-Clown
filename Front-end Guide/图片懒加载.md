##### 图片懒加载

懒加载：图片在页面首次加载时不会立即下载，只有当用户滚动到图片的可视区域时，图片才会被加载

- 页面初次加载时，图像元素不包含实际的 `src` 属性，或指向一个轻量级的占位图
- 当用户滚动页面，接近图像的位置时，JavaScript 代码检测到图像即将出现在视口中
- JavaScript 动态更新图像的 `src` 属性，使其指向实际的图像资源，浏览器随后加载并显示该图像

###### 占位处理

若无合适的占位处理，在图片懒加载过程中可能引起页面布局突然变化，进而影响用户体验

1. 固定尺寸的占位符：它的尺寸应与图片的实际尺寸相当

```HTML
<div style="width: 200px; height: 150px; background-color: #e0e0e0;">
  <img src="placeholder.png" data-src="actual-image.jpg" style="width: 100%; height: 100%; display: block;" alt="Lazy loaded image" />
</div>
```

2. CSS 或 SVG 占位图：生成更小的体积

```JavaScript
<img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 3 2'%3E%3C/svg%3E" data-src="actual-image.jpg" alt="Lazy loaded image" />
```

这段代码中的 SVG 实际上不显示任何内容，但它会占据图片原本的空间

3. JavaScript 控制图片加载

###### 监听滚动事件

```JavaScript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Optimized lazyLoad</title>
</head>
<style>
    .container {
        width: 1000px;
        margin: 0 auto;
        background-color: pink;
    }
    .container > img {
        display: block;
        width: 400px;
        height: 400px;
        margin-bottom: 50px;
    }
</style>
<body>
<div class="container">
    <img src="./img/loading.jpg" data-src="./img/pic1.png" alt="Lazy Image">
    <img src="./img/loading.jpg" data-src="./img/pic2.png" alt="Lazy Image">
    <img src="./img/loading.jpg" data-src="./img/pic3.png" alt="Lazy Image">
    <img src="./img/loading.jpg" data-src="./img/pic4.png" alt="Lazy Image">
    <img src="./img/loading.jpg" data-src="./img/pic5.png" alt="Lazy Image">
    <img src="./img/loading.jpg" data-src="./img/pic6.png" alt="Lazy Image">
</div>
<script>
    const imgs = document.querySelectorAll('img[data-src]');

    const lazyLoad = () => {
        imgs.forEach(img => {
            const rect = img.getBoundingClientRect();
            // 计算图片元素顶部与视口顶部的距离，若距离小于视口高度，说明图片即将进入视口
            if (rect.top < window.innerHeight && !img.classList.contains('loaded')) {
                img.src = img.getAttribute('data-src');
                img.classList.add('loaded'); // 标记为已加载
            }
        });
    };

    const debounce = (fn, delay) => {
        let timer = null;
        return function (...args) {
            clearTimeout(timer);
            timer = setTimeout(() => fn.apply(this, args), delay);
        };
    };

    window.addEventListener('load', lazyLoad);
    window.addEventListener('scroll', debounce(lazyLoad, 200));
    window.addEventListener('resize', debounce(lazyLoad, 200));
</script>
</body>
</html>
```

1. 避免重复加载：给每个已加载的图片添加一个 `loaded` 类，我们可以确保同一图片不会重复加载，减少不必要的网络请求，提高页面性能和用户体验
2. 性能优化：使用 `debounce` 函数优化滚动和窗口调整大小事件的处理，避免在短时间内频繁调用 `lazyLoad` 函数，提高页面性能和用户体验
3. 改进懒加载条件：检查元素是否在视口内即 `rect.top < window.innerHeight`，只有当图片进入视口时才加载图片，这符合懒加载的预期行为
4. 使用 classList 管理类名：使用 `classList.add` 方法给图片添加 `loaded` 类，比直接操作 `className` 属性更清晰

###### Intersection Observer API

```JavaScript
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.getAttribute('data-src');
      observer.unobserve(img);
    }
  });
});

document.querySelectorAll('img[data-src]').forEach(img => observer.observe(img));
```

- 在 `<img>` 标签的 `src` 属性设置一个轻量级的占位图，将实际要加载的图片 URL 设置在 `data-src` 属性中

* 使用 `IntersectionObserver` 构造函数创建一个观察者实例，定义当目标元素进入或离开可视区域时的回调函数
* 在回调函数中，检查每个元素的 `isIntersecting` 属性，如果为 `true`，说明目标元素进入视口
* 通过调用观察者的 `observe` 方法，指定需要观察的目标元素
