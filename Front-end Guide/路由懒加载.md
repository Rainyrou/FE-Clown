当一个项目首次运行时，一次性加载所有的 JavaScript 和 CSS 文件会导致显著的性能瓶颈。这是因为浏览器需要下载、解析并执行所有这些资源，才能完全显示页面，此过程可能会消耗大量的时间，特别是在网络条件不佳的情况下。路由懒加载的思想是按需加载，即只有当用户访问到某个路由时，才加载该路由对应的资源文件

- 减少初始加载的资源量，提升首屏加载速度，用户可以更快地看到首屏内容
- 对于不访问的页面不下载资源，可以节约带宽
- 减轻服务端的负担，因为资源是根据需求分批加载的，避免一次性处理大量请求的压力

###### 局限性

1. 增加首次访问特定路由页面时的加载时间：当用户导航到一个从未加载过的页面时，他需要额外时间去加载对应页面的资源
2. 用户体验：懒加载在网络较差的环境可能导致用户导航到新页面时感受到明显的延迟，影响用户体验
3. SEO：影响搜索引擎抓取，爬虫可能无法立即检索到所有按需加载的内容
4. 缓存：组件是按需加载的，但当应用更新后，客户端所需的最新版本的组件，而非缓存中的旧版本，导致额外开销
5. 代码拆分：合理实现代码拆分需要我们对项目架构有深入的理解，错误的拆分策略可能导致过多的 chunks，有额外网络请求

##### React

`src/router/index.js`

```JavaScript
import React from 'react';

const Home = React.lazy(() => import('../container/Home'));
const Data = React.lazy(() => import('../container/Data'));
const User = React.lazy(() => import('../container/User'));
const Login = React.lazy(() => import('../container/Login'));
const Detail = React.lazy(() => import('../container/Detail'));
const UserInfo = React.lazy(() => import('../container/UserInfo'));
const Account = React.lazy(() => import('@/container/Account'));

const routes = [
  {
    path: '/',
    component: Home
  },
  {
    path: '/data',
    component: Data
  },
  {
    path: '/user',
    component: User
  },
  {
    path: '/login',
    component: Login
  },
  {
    path: '/detail',
    component: Detail
  },
  {
    path: '/userInfo',
    component: UserInfo
  },
  {
    path: '/account',
    component: Account
  }
];

export default routes;
```

`src/App.js`

```JavaScript
import React, { useState, useEffect, Suspense } from 'react';
import './App.css';
import NavBar from './components/NavBar';
import { Switch, Route, useLocation } from 'react-router-dom';
import routes from './router';
import { ConfigProvider } from 'zarm';
import zhCN from 'zarm/lib/config-provider/locale/zh_CN';

function App() {
  const location = useLocation();
  const { pathname } = location; // 获取当前路径
  const needNav = ['/', '/data', '/user']; // 需要底部导航栏的路径
  const [showNav, setShowNav] = useState(false); // 是否展示 Nav

  useEffect(() => {
    setShowNav(needNav.includes(pathname));
  }, [pathname]);

  return (
    <>
      <ConfigProvider primaryColor={'#007fff'} locale={zhCN}>
        <Suspense fallback={<div>Loading...</div>}>
          <Switch>
            {routes.map((route) => (
              <Route exact key={route.path} path={route.path}>
                <route.component />
              </Route>
            ))}
          </Switch>
        </Suspense>
      </ConfigProvider>
      <NavBar showNav={showNav} pathname={pathname}></NavBar>
    </>
  );
}

export default App;
```

##### Vue

路由懒加载可通过动态 `import()` 语法实现，其为 ES6 的特性，允许你异步加载模块

```JavaScript
const Home = () => import(/* webpackChunkName: "home" */ './views/Home.vue');

const routes = [
  {
    path: '/',
    name: 'Home',
    component: Home
  }
];
```

###### 原理

1. `import` 语法允许在代码执行时请求模块，而非编译时。`import` 动态导入 Vue 组件，Webpack 在打包时会将这些组件分割成单独的 chunk，它们以数字或基于内容的哈希值命名，而 `webpackChunkName` 注释允许我们为这些异步加载的 chunk 命名，便于识别和管理
2. 在使用路由懒加载时，Webpack 结合 Vue-router 的配置，自动将应用分割成多个 chunk。这个过程中，Webpack 会分析应用，找到那些通过动态 `import` 引入的模块，并将它们分割成独立的文件
3. 当用户访问某个路由时，Vue-router 动态请求 Webpack 分割出来的对应 chunk，浏览器会异步加载这个文件，然后渲染对应的组件。这个过程是完全自动的，开发者只需要通过动态 `import` 引入路由组件即可


`SplitChunksPlugin` 是 Webpack 内置的插件，用于优化和分割 chunk，可根据需要在 `vue.config.js` 文件中自定义配置。如设置分割点、命名规则、选择哪些模块分割等

##### 自定义懒加载

[GitHub - Rainyrou/lazyload](https://github.com/Rainyrou/lazyload)

`lazyLoad.ts`

```TypeScript
import { defineAsyncComponent, defineComponent, ref, h, onMounted } from 'vue';
import type { Component, AsyncComponentLoader } from 'vue';
type ComponentResolver = (component: Component) => void;

export const lazyLoadComponentIfVisible = ({
  componentLoader,
  loadingComponent,
  errorComponent,
  delay,
  timeout
}: {
  componentLoader: AsyncComponentLoader;
  loadingComponent: Component;
  errorComponent: Component;
  delay: number;
  timeout: number;
}) => {
  let resolveComponent: ComponentResolver;
  return defineAsyncComponent({
    loader: () => new Promise((resolve) => (resolveComponent = resolve as ComponentResolver)),
    loadingComponent: defineComponent({
      setup() {
        const elRef = ref();
        const loadComponent = async () => {
          const component = await componentLoader();
          resolveComponent(component);
        };

        onMounted(async () => {
          if (!('IntersectionObserver' in window)) {
            await loadComponent();
            return;
          }
          const observer = new IntersectionObserver(async (entries) => {
            if (!entries[0].isIntersecting) return;
            observer.unobserve(elRef.value);
            await loadComponent();
          });
          observer.observe(elRef.value);
        });

        return () => h('div', { ref: elRef }, loadComponent);
      }
    }),
    delay,
    errorComponent,
    timeout
  });
};
```

`App.vue`

```JavaScript
import Loading from './components/Loading.vue';
import { lazyLoadComponentIfVisible } from './utility/lazyLoad';

const LazyLoaded = lazyLoadComponentIfVisible({
  componentLoader: () => import('./components/HelloWorld.vue'),
  loadingComponent: Loading,
});
```
