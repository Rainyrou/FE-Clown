**问题**

- 状态丢失 -> 切换页面时原先页面数据完全丢失
- 删除单页数据时全局数据受到影响，实际全局数据未保存或存储有误

###### 1. 状态丢失

当切换分页时，确保每个分页的状态（如表单填写的数据）被保存起来，以便在用户返回该页时能恢复之前的状态

**解决方案**：

- 使用 Pinia 来全局存储每一页的数据状态或在组件的 data 选项中定义一个对象来存储每一页的状态
- 当用户切换分页时，保存当前页的状态到全局状态库或组件的 data 中，并在切回该页时从存储中恢复该状态

###### 2. 保存与回显数据

当保存数据时，确保更新界面上的显示，同时更新存储的状态数据

**解决方案**：

- 在执行保存操作时，确保将当前页面的状态更新到全局状态存储中
- 在 init 界面或进行回显时，确保从全局状态存储中读取所有分页的数据，并正确渲染到对应的分页上

###### 3. 删除单页数据与全局数据

确保删除操作只影响当前页的数据，而不会影响全局数据

**解决方案**：

- 在执行删除操作时，仅对当前页的状态进行修改，不直接操作全局数据
- 在全局数据中删除项时，确保正确识别并删除目标项，防止误操作

###### 4. 数据变化及时更新

当数据变化如增删改查时，确保及时更新全局状态和当前页的显示

**解决方案**：

- 使用 Vue 的响应式数据和计算属性来确保当全局状态变化时，自动更新相关的界面
- 在进行任何数据操作后，重新计算分页数据，并更新界面显示

##### 关于 bug

1. 本组中的用户 -> delete 操作

- 切换页面时原有页面的状态丢失
- 选中单页面五个选项默认选择所有选项
- 删除单页面某些数据时，数据关系混乱，某些情况下单页面数据被当作全局数据

3. 刷新页面首先要保证分页 -> 单页数据的处理，存储 where，但同时应保证不能混淆，单页数据不应取代全局数据，即刷新页面后增删保存**界面 + 状态**都有问题

- 页面刷新会**丢失当前页面的所有状态**，包括 Vue 实例的状态
- 页面刷新后，Vue 实例的生命周期将重新开始，但不会保留之前的状态
- 若需要在页面刷新后保持某些状态，考虑使用 localStorage 或 sessionStorage 来存储这些状态

###### 生命周期钩子

刷新页面会销毁当前 Vue 实例，并创建一个新的实例，因此刷新页面会触发一系列生命周期钩子

1. `beforeCreate`
2. `created`
3. `beforeMount`
4. `mounted`

###### 关于 watch

1. `watch(() => props.id, fn)` 使用一个返回 `props.id` 的值的函数作为第一个参数，它是一个响应式引用，此法为 Lazy Watching。这里 `watch` 追踪函数内部所访问的响应式属性，即 `props.id`。只有当修改 `props.id` 的值才会触发侦听器 `fn`

- 你可以访问组件的上下文，且能侦听多个响应式源的组合结果

2. `watch(props.id, fn)` 直接将 `props.id` 作为第一个参数。Vue 3 不支持此法，因为 `props.id` 是一个响应式引用，而 `watch` 需要一个 Ref 或响应式对象的属性路径作为监听源。若 `props.id` 本身是一个 Ref（如它通过 `toRef` 或 `ref` 创建），这种写法是有效的；否则，必须使用一个函数来返回 `props.id` 的值