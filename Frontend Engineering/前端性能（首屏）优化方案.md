前端性能优化按粒度大致可分为：

- 页面级别优化，如减少 HTTP 请求数、脚本的无阻塞加载、内联脚本的位置优化
- 代码级别优化，如 JavaScript DOM 操作优化、图片优化及 HTML 结构优化

前端优化可提升用户体验，对用户操作响应得更及时，加快页面加载速度，减少页面请求数，减小请求所占带宽，节省服务器资源

#### 减少 HTTP 请求

前端加载的大部分时间在于下载各种资源，浏览器对于同一个服务器的 HTTP 请求连接池数量是有限的，过多请求需要排队等候，最小化 HTTP 请求能避免 HTTP 连接池被占满，同时也能避免过多 HTTP 链接时 TCP 握手造成的时间消耗

##### CSS Sprite

CSS Sprite 雪碧图，合并多张图片，减少图片请求数量

```JavaScript
.icon {
  background-image: url('spritesheet.png');
  background-position: -20px -10px;
  width: 20px;
  height: 20px;
}
```

##### Image Maps

图像映射允许在单个图像上定义多个可点击的区域。每个区域可以链接到不同的目标。但其在 Web 开发中使用较少，因为维护成本高，且不够灵活

```JavaScript
<img src="image.jpg" usemap="#mapname" alt="description">
<map name="mapname">
  <area shape="rect" coords="0,0,50,50" href="link1.html" alt="Link 1">
  <area shape="circle" coords="100,100,50" href="link2.html" alt="Link 2">
</map>
```

##### Inline Images

使用 Base64 编码的图片直接嵌入 HTML 或 CSS，适用于体积较小的图片

```JavaScript
.icon {
  background-image: url(data:image/png;base64,ACTUAL-DATA-HERE);
}
```

##### Font Icon

使用字体图标而不是传统的图片图标。矢量图形，可轻松缩放和更改颜色

```JavaScript
@font-face {
  font-family: 'FontIcon';
  src: url('fonticon.woff2') format('woff2');
}

.icon {
  font-family: 'FontIcon';
}
```

##### Combined Files

使用构建工具将多个 CSS 或 JavaScript 文件合并为单文件

#### 优化网络请求

##### CDN

CDN（Content Delivery Network）是基于 DNS 协议实现的一种分布式网络，它使用"边缘计算"原理，通过在各地部署多个节点服务器，将网站或互联网应用的内容分发到最接近用户的节点，从而更快更可靠地将内容送达给用户

###### CDN 的核心工作原理

- CDN 提供商在全球范围内的多个地点部署节点服务器，这些节点服务器会缓存源服务器上的内容
- 当用户请求一个通过 CDN 服务加速的网站或资源时，该请求首先会到达 DNS 服务器。DNS 解析系统会解析并返回最接近用户且负载较低的 CDN 节点的 IP 地址（负载均衡）
- 用户的请求被重定向到所选的 CDN 节点。用户从这个节点获取内容，这个节点就像该用户的本地服务器。如果所请求的内容已经缓存在这个节点，它将直接从此节点传输到用户。如果内容在该节点上未被缓存，该节点将从源服务器或其他节点获取内容，缓存一份，并将其传输到用户
- CDN 节点定期检查内容的有效性，并依据预设的策略（如时间戳或 ETag）更新过期或更改的内容，确保其节点上的内容是最新的

##### DNS

DNS Prefetch 是一种技术，通过预先获取域名的 IP 地址来减少实际请求的延迟。当浏览器遇到域名时，它不必等待 DNS 解析过程，因为解析已在后台完成，这可以加速外部资源的加载速度。

DNS (Domain Name System) 作为域名和 IP 地址之间的映射系统，允许人们使用易于记忆的域名（如 `example.com`）来访问特定的服务器，而服务器实际上是通过 IP 地址（如 `192.168.1.1`）来定位的。以下是 DNS 的一般查询流程以及解析域名的实现机制

###### DNS 查询流程：

1. 当用户在浏览器中输入一个 URL 并按 Enter 键后，浏览器会首先查找自己的 DNS 缓存（这个缓存只有浏览器自己可以访问）看是否已经存储了这个域名对应的 IP 地址
2. 如果没有找到，操作系统会检查本地的 `hosts` 文件。`hosts` 文件是一个系统文件，允许手动映射域名到特定的 IP 地址
3. 如果没有找到，操作系统会查找自己的 DNS 缓存是否有这个域名对应的 IP 地址
4. 如果上述步骤都没有找到域名对应的 IP 地址，操作系统会将 DNS 查询请求发送到本地网络配置中指定的 DNS 服务器。这个服务器通常是由 ISP（Internet Service Provider）提供的
5. 如果本地 DNS 服务器没有缓存该域名对应的 IP 地址，它开始一个迭代查询过程：询问根 DNS 服务器->根据根 DNS 服务器的指引，询问相应的顶级域（TLD）服务器（如 `.com`、`.org` 等）->根据 TLD 服务器的指引，询问权威 DNS 服务器(二级域名和更多级的域名都在权威域名服务器解析)
6. 权威 DNS 服务器回应本地 DNS 服务器查询请求，提供域名对应的 IP 地址，或者返回一个错误（如域名不存在）
7. 本地 DNS 服务器将查询结果（无论是 IP 地址还是错误）缓存一定时间（根据 DNS 记录的 TTL，即 Time to Live 值决定），以便下次有相同的查询请求时，可以直接从缓存中提供答案
8. 本地 DNS 服务器将查询结果返回给发起查询的客户端程序
9. 客户端程序（如操作系统或 Web 浏览器）可能也会缓存这个结果，以便将来需要时能更快地解析相同的域名

- 分层为了通过负载均衡来分散压力，三级分层（根域名服务器、顶级域名服务器、权威域名服务器）在实践中被证明是既能满足全球互联网需求，又能保持稳定和有效的一个层次
- 在编程层面，实现一个 DNS 客户端或服务器需要深入了解网络编程和 DNS 协议的细节。大部分现代操作系统和编程语言都提供了抽象级别更高的库或接口，使得开发人员无需直接处理 DNS 协议的复杂性

##### 配置 ETag

ETag 是一个可以与 Web 资源关联的标识符，用于判断该资源是否已更改。服务器生成 ETag，并在响应头中发送。浏览器存储这个 ETag 值，并在下次请求同一资源时将其发送回服务器。服务器比较客户端 ETag 和服务器上的 ETag，以确定资源是否已更改

优点：

1. 减少不必要的数据传输，因为如果资源没有变化，服务器可以返回一个 304 未修改的响应
2. 更有效地使用浏览器缓存

##### 尽早释放缓冲

服务端可以在页面生成的同时，将部分已生成的 HTML 内容提前发送给客户端，使其开始解析并加载相关资源

优点：

1. 更快地展示给用户页面的部分内容
2. 在等待服务端完全生成页面时，浏览器已开始加载其他资源，提高了页面的整体加载速度

#### 利用缓存控制

##### 缓存控制

通过服务端设置响应头的 `Expires` 与 `Cache-Control` 来设置资源组件过期时间及过期策略，对于静态资源可通过设置 `Expires` 为长期时间以实现永不过期策略，对于动态组件可通过 `Cache-Control` 指定缓存机制来辅助浏览器处理条件请求

##### 外部引用

将 JavaScript 与 CSS 设置为外部文件引入而不是直接嵌入到 HTML 中，由于浏览器的缓存机制，外部文件可通过浏览器的缓存引入而无需每次重复请求同一资源文件，加快页面打开速度。但引入外部文件会增加 HTTP 请求数量，关键问题在于如何平衡 HTML 文档数量，缓存外部 JavaScript 与 CSS 文件数量

#### 优化资源加载

##### 样式位置

根据浏览器渲染顺序，在 `<head>` 中引入 CSS，相对于 `<body>` 或 `<footer>` 来说，可加快页面渲染速度

##### 脚本位置

浏览器可并发请求，然而在加载时外部引入 JavaScript 却会阻塞其他资源，如在脚本加载完成之前，它后面的图片、样式及其他脚本都处于阻塞状态，直到脚本加载完后才开始加载，原因之一是 JS 可能会改变页面或 JS 间的依赖关系，因此需要严格保证顺序，无法并行下载。因此尽可能将 JS 往后挪，减少对并发下载和页面渲染的影响

##### SSR 服务端渲染

服务端渲染可以加快页面加载速度，因为 HTML 是由服务器生成并直接发送到客户端的，减少了客户端渲染的时间

使用 Next.js、Nuxt.js 等框架，它们提供了 SSR 功能的支持

#### 压缩资源

- 压缩文件：使用工具如 UglifyJS 和 CSSNano 来压缩文件
* 使用 Gzip 或 Brotli 显著减少 HTTP 响应大小
* 图片优化：使用压缩工具（如 TinyPNG）或使用更高效的格式（如 WebP）
* 按需加载：使用 Webpack 等模块打包工具的动态导入 `import()` 来实现代码分割和懒加载

#### 优化代码

##### 使用更高效的数据结构和算法

##### 避免 CSS 表达式

CSS 表达式通过 `expression` 方法来接受 JavaScript 表达式。它的问题在于其频繁的计算（远超乎我们的想象），影响页面性能。替代的方案：可使用 JS 计算属性并赋值给 CSS 属性，若需要在页面的整个生命周期中动态设置 CSS 属性，可使用事件处理程序

##### 避免重定向

页面发生重定向会延迟整个 HTML 文档的传输。在 HTML 文档到达之前，页面不会呈现任何东西，也不会下载任何组件。若非要要使用重定向，请使用 301 重定向。因为若使用 302，每次访问页面都会发生重定向，而浏览器会记住永久重定向后的地址，每次访问页面，都会直接返回重定向后的页面

##### 最小化操作 DOM

JavaScript 操作 DOM 无可避免地会触发浏览器的重绘回流，而重绘和回流的代价比较昂贵

为减少发生次数：

###### 解决方案

1. 动态修改样式而非直接修改

```JavaScript
element.classList.add('new-class');
```

2. 修改 CSS class 属性，而非直接修改 style 属性
3. 避免在循环中直接操作样式，如有必要，使用 `DocumentFragment` 进行批量样式更改，然后一次性更新 DOM

```JavaScript
const fragment = document.createDocumentFragment();

for (let i = 0; i < items.length; i++) {
    const li = document.createElement('li');
    li.textContent = items[i];
    fragment.appendChild(li);
}

myList.appendChild(fragment);
```

4. 避免频繁读取会触发重绘或回流的属性：如 `offsetTop`、`offsetLeft`、`offsetWidth`、`offsetHeight`、`clientTop`、`clientLeft`、`clientWidth`、`clientHeight`、`scrollTop`、`scrollLeft`、`scrollWidth`、`scrollHeight`、`width`、`height`、`getComputedStyle()` 等，如需多次使用，可将其缓存
5. 避免使用 table 布局，表格布局比其他布局更容易触发回流
6. 使用 CSS3 动画代替 JavaScript 动画，因为 CSS3 动画会被浏览器优化
7. 使用绝对定位的元素进行动画，因为它们的变化不会影响其他元素的布局
8. 使用 `transform` 和 `opacity` 进行动画，它们不会触发重绘和回流
9. 使用 `requestAnimationFrame` 而不是 `setTimeout` 或 `setInterval` 进行动画，可以确保动画的每一帧都与浏览器的重绘过程同步
