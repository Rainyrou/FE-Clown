请补全 JavaScript 代码，要求以 Boolean 的形式返回字符串参数是否为合法的 URL 格式。  
注意：

1. 协议仅为 HTTP(S)

```JavaScript
const isUrl = url => /^((https|http|ftp|rtsp|mms)?:\/\/)(([A-Za-z0-9]+-[A-Za-z0-9]+|[A-Za-z0-9]+)\.)+([A-Za-z]{2,6})(:\d+)?(\/.*)?(\?.*)?(#.*)?$/.test(url);
```

* 协议部分可选

* 主机名可以使用"-"符号，所以两种情况都要判断，包含"-"或不包含"-"

* 顶级域名为2-6位 `

* 端口、请求路径、传参及哈希值

正则表达式是用于匹配字符串中字符组合的模式，这些模式可以用来检测字符串中的某些字符组合，替换匹配到的部分，或者将字符串拆分为多个部分。在 JavaScript 中，正则表达式也是对象

##### 如何创建正则表达式？

1. 正则表达式字面量：直接在两个斜杠之间写入模式，例如：

```JavaScript
let re = /ab+c/;
```

这种方式的优势在于它在脚本加载时即被编译，对于不变的正则表达式，性能更优

2. 使用 `RegExp` 构造函数：

```JavaScript
let re = new RegExp("ab+c");
```

这种方式在脚本运行时编译正则表达式。对于正则表达式模式是动态的或取决于用户输入，应使用此方法

##### 正则表达式的模式

1. 简单模式：由字面字符构成，例如 `/abc/` 仅匹配字符串中的"abc"
2. 带有特殊字符的模式

正则表达式主要依赖于元字符。 元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：

| 元字符 | 描述                                                            |
| :----: | --------------------------------------------------------------- |
|   .    | 句号匹配除换行符外任意单个字符                                  |
|  [ ]   | 字符种类。匹配方括号内的任意字符                                |
|  [^ ]  | 否定的字符种类。匹配除了方括号里的任意字符                      |
|   \*   | 匹配 >=0 个重复的在 \* 号之前的字符                             |
|   +    | 匹配 >=1 个重复的 + 号前的字符                                  |
|   ?    | 标记 ? 之前的字符为可选                                         |
| {n,m}  | 匹配 num 个大括号之前的字符或字符集 (n <= num <= m)             |
| (xyz)  | 字符集，匹配与 xyz 完全相等的字符串                             |
|   \|   | 或运算符，匹配符号前或后的字符                                  |
|   \\   | 转义字符,用于匹配一些保留的字符  `[ ] ( ) { } . * + ? ^ $ \ \|` |
|   ^    | 从开始行开始匹配                                                |
|   $    | 从末端开始匹配                                                  |

###### 正则表达式中的一些术语

- 断言（Assertions）：定义了某些匹配必须满足的条件
- 字符类（Character Classes）：定义了应该匹配哪种类型的字符，如数字、字母或其他字符
- 组和范围（Groups and Ranges）：允许我们将部分正则表达式分组或定义一个字符范围
- 量词（Quantifiers）：定义了字符或组合应该出现多少次
- Unicode 属性转义（Unicode Property Escapes）：基于 Unicode 属性来匹配字符

##### 要点

- 字符集也叫做字符类。 方括号用来指定一个字符集， 在方括号中使用连字符来指定字符集的范围， 在方括号中的字符集不关心顺序。 例如，表达式 `[Tt]he`  匹配  `the`  和  `The`

- 方括号的句号就表示句号。 表达式  `ar[.]`  匹配  `ar.` 字符串

- 一般来说  `^`  表示一个字符串的开头，但它用在一个方括号的开头时，表示这个字符集是否定的。 例如，表达式 `[^c]ar`  匹配一个后面跟着 `ar` 的除了 `c` 的任意字符

- `*` 号匹配在 `*` 之前的字符出现大于等于 0 次。 例如，表达式  `a*`  匹配 0 或多个以 a 开头的字符。表达式 `[a-z]*`  匹配一个行中所有以小写字母开头的字符串

`[a-z]*` => T**he** **parked** **in** **the** **garage** #21.

- `*` 字符和 `.` 字符搭配可以匹配所有的字符 `.*`。 `*` 和表示匹配空格的符号 `\s` 连起来用，如表达式 `\s*cat\s*` 匹配 0 或多个空格开头和 0 或多个空格结尾的 cat 字符串

`\s*cat\s*` => the fat **cat** sat on the con**cat**enation

- `+` 号匹配 `+` 号之前的字符出现 >=1 次。 例如表达式 `c.+t`  匹配以首字母 `c` 开头以 `t` 结尾，中间跟着至少一个字符的字符串

`c.+t` => The fat **cat sat on the mat**

- 在正则表达式中  `{}`  是一个量词，用来限定一个或一组字符可以重复出现的次数，第二个参数可以省略。如 `[0-9]{2,}`  匹配至少两位 0~9 的数字。如果逗号也省略掉，则表示重复固定的次数，如 `[0-9]{3}`  匹配 3 位数字

- 特征标群是一组写在  `(...)`  中的子模式，`(...)`  中包含的内容将会被看成一个整体。如 `(c|g|p)ar`  匹配  `car`  或  `gar`  或  `par`

- 反斜线  `\`  在表达式中用于转义紧跟其后的字符，用于指定  `{ } [ ] / \ + * . $ ^ | ?`  这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线  `\`

##### 简写字符集

| 简写 | 描述                                                |
| :--: | --------------------------------------------------- |
|  .   | 除换行符外的所有字符                                |
|  \w  | 匹配所有字母数字及下划线，等同于  `[a-zA-Z0-9_]`            |
|  \W  | 匹配所有非字母数字，即符号，等同于： `[^\w]`        |
|  \d  | 匹配数字： `[0-9]`                                  |
|  \D  | 匹配非数字： `[^\d]`                                |
|  \s  | 匹配所有空格字符，等同于： `[\t\n\f\r\p{Z}]`        |
|  \S  | 匹配所有非空格字符： `[^\s]`                        |
|  \f  | 匹配一个换页符                                      |
|  \n  | 匹配一个换行符                                      |
|  \r  | 匹配一个回车符                                      |
|  \t  | 匹配一个制表符                                      |
|  \v  | 匹配一个垂直制表符                                  |
|  \p  | 匹配 CR/LF（等同于  `\r\n`），用来匹配 DOS 行终止符 |

##### 零宽度断言（前后预查）

先行断言和后发断言（合称 lookaround）都属于非捕获组（用于匹配模式，但不包括在匹配列表中）。当我们需要一个模式的前面或后面有另一个特定的模式时，就可以使用它们

例如，我们希望从下面的输入字符串  `$4.44`  和  `$10.88`  中获得所有以  `$`  字符开头的数字，我们将使用以下的正则表达式  `(?<=\$)[0-9\.]*`。意思是获取所有包含  `.`  并且前面是  `$`  的数字

零宽度断言如下：

| 符号 | 描述            |
| :--: | --------------- |
|  ?=  | 正先行断言-存在 |
|  ?!  | 负先行断言-排除 |
| ?<=  | 正后发断言-存在 |
| ?<!  | 负后发断言-排除 |

###### 1.正先行断言

正先行断言 `?=...` 表示第一部分表达式之后必须跟着  `?=...` 定义的表达式。返回结果只包含满足匹配条件的第一部分表达式。 定义一个正先行断言要使用  `()`，在括号内部使用一个问号和等号 `(?=...)`

正先行断言的内容写在括号中的等号后面。 例如，表达式  `(T|t)he(?=\sfat)`  匹配  `The`  和  `the`，在括号中我们又定义了正先行断言  `(?=\sfat)` ，即  `The`  和  `the`  后面紧跟着  `(空格)fat`

`(T|t)he(?=\sfat)` => **The** fat cat sat on the mat.

###### 2.负先行断言

负先行断言 `?!...` 用于筛选所有匹配结果，筛选条件为其后不跟随着断言中定义的格式。  正先行断言定义和负先行断言一样，区别就是  `=`  替换成  `!`  也就是  `(?!...)`。表达式  `(T|t)he(?!\sfat)`  匹配  `The`  和  `the`，且其后不跟着  `(空格)fat`

`(T|t)he(?!\sfat)` => The fat cat sat on **the** mat.

###### 3.正后发断言

正后发断言 `(?<=...)`  用于筛选所有匹配结果，筛选条件为其前跟随着断言中定义的格式。 例如，表达式  `(?<=(T|t)he\s)(fat|mat)`  匹配  `fat`  和  `mat`，且其前跟着  `The(空格)`  或  `the(空格)`

`(?<=(T|t)he\s)(fat|mat)` => The **fat** cat sat on the **mat**.

###### 4.负后发断言

负后发断言  `(?<!...)`  用于筛选所有匹配结果，筛选条件为其前不跟随着断言中定义的格式。 例如，表达式  `(?<!(T|t)he\s)(cat)`  匹配  `cat`，且其前不跟着  `The(空格`  或  `the(空格)`

`(?<!(T|t)he\s)(cat)` => The cat sat on **cat**.

##### 标志

标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。 这些标志可以任意的组合使用，它也是整个正则表达式的一部分

| 标志 | 描述                                                  |
| :--: | ----------------------------------------------------- |
|  i   | 忽略大小写                                            |
|  g   | 全局搜索                                              |
|  m   | 多行修饰符：锚点元字符  `^` `$`  工作范围在每行的起始 |

###### 忽略大小写 (Case Insensitive)

修饰语  `i`  用于忽略大小写。 例如，表达式  `/The/gi`  表示在全局搜索  `the`  和  `The`，在后面的  `i`  将其条件修改为忽略大小写

###### 全局搜索 (Global search)

修饰符  `g`  用于执行一个全局搜索匹配，返回全部。 如表达式  `/.(at)/g`  表示搜索除换行符外的任意字符和  `at`，并返回全部结果

`/.(at)/g` => The **fat** **cat** **sat** on the **mat**.

###### 多行修饰符 (Multiline)

多行修饰符  `m`  用于执行一个多行匹配

`/.at(.)?$/gm` => The **fat**
cat **sat**
on the **mat.**

###### 贪婪匹配与惰性匹配 (Greedy vs lazy matching)

正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用  `?`  将贪婪匹配模式转化为惰性匹配模式

`/(.*at)/` => **The fat cat sat on the mat**.

`/(.*?at)/`=> **The fat** cat sat on the mat.

##### 底层原理

JavaScript 的正则表达式是通过内部的有限自动机来实现的。有限自动机是一种计算模型，可识别并处理正则语言。当你执行一个正则表达式操作时，JavaScript 首先编译这个表达式，然后在给定的字符串上运行生成的有限自动机

#### 参考

[正则表达式 - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_expressions)

[GitHub - ziishaned/learn-regex: Learn regex the easy way](https://github.com/ziishaned/learn-regex/tree/master)