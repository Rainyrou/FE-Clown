* 维护大小为 K=1000 的最小堆，堆顶元素即该 1000 个数字中的最小值
* 遍历 100 万个数字，若当前数字小于等于堆顶元素，直接忽略，否则弹出堆顶元素，将当前数字插入堆中，通过这种方式，堆始终维护着遍历至当前位置的最大 1000 个数字
- 时间复杂度 -> O(NlogK) 空间复杂度 ->  O(K)

[数组中的第 K 个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

```js
const findTopK = (nums, k) => {
  if (nums.length <= k) return nums.sort((a, b) => b - a);
  let heapSize = nums.length;
  buildMaxHeap(nums, heapSize);
  for (let i = nums.length - 1; i >= nums.length - k; --i) {
    [nums[0], nums[i]] = [nums[i], nums[0]];
    --heapSize;
    maxHeapify(nums, 0, heapSize);
  }
  return nums.slice(nums.length - k).reverse();
};

const buildMaxHeap = (nums, heapSize) => {
  for (let i = (heapSize >> 1) - 1; i >= 0; --i) maxHeapify(nums, i, heapSize);
};

const maxHeapify = (nums, i, heapSize) => {
  while (i < heapSize) {
    let largest = i;
    let left = i * 2 + 1,
      right = i * 2 + 2;
    if (left < heapSize && nums[left] > nums[largest]) largest = left;
    if (right < heapSize && nums[right] > nums[largest]) largest = right;
    if (i !== largest) {
      [nums[i], nums[largest]] = [nums[largest], nums[i]];
      i = largest;
    } else {
      break;
    }
  }
};
```

`maxHeapify` 维护以索引 i 为根节点的子树满足最大堆性质
`buildMaxHeap` 叶子节点无需调整，因此从最后一个非叶子节点开始调用 `maxHeapify` 函数