```JavaScript
class Singleton {
    constructor(name, age) {
        if(!Singleton.instance) {
            this.name = name;
            this.age = age;
            Singleton.instance = this;
        }
        return Singleton.instance;
    }
};

console.log(new Singleton('Clown', 21) === new Singleton('Rainy', 18)); // true
```

###### 底层原理

在JavaScript中，当使用 `new` 关键字调用构造函数时，一个新的对象会被创建，且 `this` 关键字会引用这个新对象。然而，如果构造函数显式地返回一个对象，则 `new` 操作将返回该对象，而不是之前提到的新对象。这是我们在单例模式中利用的特性：首次调用构造函数时，我们返回新创建的对象实例；但在随后的调用中，我们直接返回第一次创建的实例

###### 基础知识

单例模式是一种创建型设计模式，其涉及到一个单一的类，该类负责创建所需的对象，同时确保只有单个对象被创建，这个类提供了一种访问其唯一的对象的方式，保证访问的对象是只实例化一次的对象类

单例模式主要用于那些需要确保某个类只创建一个对象，如数据库连接、日志记录、驱动程序对象、线程池等。确保只有一个实例可避免由于多次实例化导致的资源浪费或不一致的行为

1. 私有构造函数：为避免外部代码使用 `new` 操作符创建对象实例，单例类的构造函数应该是私有的
2. 静态实例：单例类持有自己类型的一个静态实例，这确保只有这个实例是可用的
3. 全局访问点：单例类提供一个静态方法来让外部代码访问这个唯一的实例。这个方法通常被命名为 `getInstance`
4. 延迟初始化：为了节省资源和提高效率，单例实例经常会在第一次被请求时进行初始化，这被称为延迟初始化或惰性初始化

优点：
* 节省资源
* 控制并发访问
* 全局访问：单例模式可以确保所有代码都使用同一个实例，因此可以从任何地方访问和更改数据

不足：
* 全局状态可能导致未预期的行为，特别是在多线程环境下
* 隐藏其构造函数并使用静态方法，可能导致测试困难
* 违反单一职责原则，单例类通常在执行业务逻辑的同时还负责保证自己的单例状态