```js
Array.prototype._quickSort = function () {
  const helper = (arr) => {
    if (arr.length <= 1) return arr;
    const pivot = arr[arr.length - 1];
    const left = [],
      right = [];
    for (let i = 0; i < arr.length; ++i) {
      if (arr[i] < pivot) left.push(arr[i]);
      else right.push(arr[i]);
    }
    return [...helper(left), pivot, ...helper(right)];
  };
  const res = helper(this);
  for (let i = 0; i < res.length; ++i) this[i] = res[i];
};
```

- 时间复杂度：最好/平均情况 -> O(n log n) 即递归深度 log(n) \* 各层分割 O(n) ，最坏情况 -> O(n²) + 选取基准为最小或最大元素
* 空间复杂度：最好/平均情况 -> O(n log n) 即递归深度 log(n) \* 各层空间 O(n)，最坏情况 -> O(n²)

### 时间复杂度

#### 最佳情况（O(n log n)）

- 在最佳情况下，每次选取的基准（pivot）能够将数组均匀地分成两半。这样，在每一层递归中，数组都被分成大约相等的两部分。
- 分割过程进行 log(n) 层，每一层的分割操作需要 O(n) 的时间。
- 因此，总时间复杂度为 O(n log n)。

#### 最坏情况（O(n^2)）

- 在最坏情况下，每次选取的基准都是数组中的最小或最大元素。这样，数组在每次递归时只会减少一个元素。
- 这种情况下，递归会进行 n 层，每一层的分割操作需要 O(n) 的时间。
- 因此，总时间复杂度为 O(n^2)。

#### 平均情况（O(n log n)）

- 平均情况下，基准能够将数组大致均匀地分成两半。虽然并不完全均匀，但整体上接近于对半分割。
- 这种情况下，时间复杂度仍然为 O(n log n)。

### 空间复杂度

- 这个实现的快排使用了大量的额外数组来存储左右分区，这意味着在每个递归层都需要额外的空间。
- 在最佳和平均情况下，空间复杂度为 O(n log n)，因为递归的深度为 log(n)，每层需要 O(n) 的额外空间来存储左右分区。
- 在最坏情况下（例如，递归深度达到 n），空间复杂度为 O(n^2)，因为每一层都在创建新的子数组。
