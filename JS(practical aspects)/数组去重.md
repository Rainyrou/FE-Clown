变式：内容相同的对象需要去重， 将对象序列化为字符串以确保内容完全相同的对象生成相同标识

```js
const _deleteRepeat = (arr) => {
  const ans = [],
    set = new Set();
  for (const item of arr) {
    let key;
    if (typeof item === "object" && item !== null) key = JSON.stringify(item);
    else key = item;
    if (!set.has(key)) {
      set.add(key);
      ans.push(item);
    }
  }
  return ans;
};
```

###### 方法一：Set

```JavaScript
const array = [1, 2, 2, 3, 3, 4, 5];
const _deleteRepeat = (arr) => [...new Set(arr)];
console.log(_deleteRepeat(array)); // [ 1, 2, 3, 4, 5 ]
```

###### 方法二：indexOf

```js
const _deleteRepeat = (arr) => {
  const res = [];
  arr.forEach((item) => {
    const index = res.indexOf(item);
    if (index === -1) res.push(item);
  });
  return res;
};
```

###### 方法三：includes

```JavaScript
const array = [1, 2, 2, 3, 3, 4, 5];
const _deleteRepeat = (arr) => {
  const ans = [];
  arr.forEach((item) => {
    if (!ans.includes(item)) ans.push(item);
  });
  return ans;
};
console.log(_deleteRepeat(array)); // [ 1, 2, 3, 4, 5 ]
```

###### 方法四：Map

```JavaScript
const array = [1, 2, 2, 3, 3, 4, 5];
const _deleteRepeat = (arr) => {
  const map = new Map();
  arr.forEach((item) => map.set(item, true));
  return Array.from(map.keys());
};
console.log(_deleteRepeat(array)); // [ 1, 2, 3, 4, 5 ]
```

###### 方法五：filter + indexOf

若相同逻辑需复用，可将其封装成一个函数：

```JavaScript
const array = [1, 2, 2, 3, 3, 4, 5];
const _deleteRepeat = (arr) => {
  return arr.filter((item, index) => {
    return arr.indexOf(item) === index;
  });
};
console.log(_deleteRepeat(array)); // [ 1, 2, 3, 4, 5 ]
```

若无需复用：

```JavaScript
const arr = [1, 2, 2, 3, 3, 4, 5];
const _deleteRepeat = arr.filter((item, index) => arr.indexOf(item) === index);
console.log(_deleteRepeat); // [ 1, 2, 3, 4, 5 ]
```



