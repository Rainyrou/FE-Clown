1. 浅拷贝只拷贝指向引用类型对象的堆内存之指针，拷贝的只是引用，深拷贝拷贝引用类型对象的所有属性到一个新对象，若其属性仍引用其他对象，则递归进行深拷贝。浅拷贝只拷贝对象第一层属性，而深拷贝递归拷贝对象所有层级
2. WeakMap 为一组键值对的集合，其键为引用数据类型，其持有的是对象的弱引用，当无对 WeakMap 键的强引用时，这些键对应的对象可被垃圾回收

```JavaScript
const _shallowClone = target => {
    if(target === null || typeof target !== 'object') return target;
    const constructor = target.constructor;
    if(/^(Function|RegExp|Date|Map|Set)$/i.test(constructor.name)) return target;
    const clonedTarget = Array.isArray(target) ? [] : {};
    for(let prop in target) {
        if(target.hasOwnProperty(prop)) clonedTarget[prop] = target[prop];
    }
    return clonedTarget;
};
```

```js
const _completeDeepClone = (target, map = new WeakMap()) => {
  if (typeof target !== "object" || target === null) return target;
  const constructor = target.constructor;
  if (/^(Function|RegExp|Date|Map|Set)$/i.test(constructor.name))
    return new constructor(target);
  if (map.has(target)) map.get(target);
  map.set(target, true);
  const clonedTarget = Array.isArray(target) ? [] : {};
  for (let prop in target) {
	// 判断对象的自有属性（非继承来的属性）中是否具有指定的属性
	// 确保只复制对象自己的属性，而不是其原型链上的属性
    if (target.hasOwnProperty(prop))
      clonedTarget[prop] = _completeDeepClone(target[prop], map);
  }
  return clonedTarget;
};
```

测试用例：

```js
console.log(_completeDeepClone(42));
console.log(_completeDeepClone(new Date()));
console.log(_completeDeepClone([1, 2, 3, [4, 5]]));
console.log(_completeDeepClone({ a: 1, b: { c: 2 } }));
```

