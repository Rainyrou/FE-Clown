
| 维度   | `interface` 底层逻辑  | `type` 底层逻辑        |
| ---- | ----------------- | ------------------ |
| 设计定位 | 结构契约（对象/类的结构描述）   | 类型别名（任意类型的缩写与组合）   |
| 类型范围 | 对象/类/函数结构         | 所有 TS 类型           |
| 扩展机制 | `extends` 结构拓展    | `&` 交叉类型           |
| 声明合并 | 支持（结构合并，方法重载）     | 不支持（别名唯一，重复报错）     |
| 编译性能 | 惰性求值，按需递归判断结构是否匹配 | 立即求值，递归解析类型别名的原始类型 |


1. any：放弃类型检查，相当于 JavaScript
2. undefined：变量未初始化/函数无返回值/可选属性未传入，相当于 JavaScript undefined
3. never：不可能状态，无法创建 `never` 类型实例，`never` 可赋值给任何类型，但无法反过来，`never` 与任何类型的联合类型，结果仍为该类型本身
4. unknown：强制安全校验

`unknown`  报错本质为 TypeScript 类型系统对未验证类型的安全限制即违反以下规则：

- 赋值约束：`unknown`  可赋值给  `unknown/any`，无法赋值给其他类型
- 类型约束：`unknown`  无法兼容非  `unknown/any`  类型的类型守卫
- 操作约束：无法对  `unknown`  进行运算操作、属性访问和方法调用

解决方案：

- 泛型约束 + 类型推断：在定义时通过泛型约束限制变量/函数类型，避免出现  `unknown`
- 显式类型收窄：`typeof/instanceof/Array.isArray`、 `if-else/switch`  链式判断和自定义类型守卫收窄类型，让 TypeScript 编译器明确  `unknown`  的具体类型
- 内置工具类型收窄
- 类型断言：跳过 TypeScript 编译器的类型校验，直接将  `unknown`  指定为目标类型
