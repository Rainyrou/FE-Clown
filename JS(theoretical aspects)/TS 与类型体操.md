TypeScript 的「类型体操」概念源于其图灵完备的类型系统，这是一种工程化的防御手段，随项目对类型安全要求越来越高，前端开始探索如何在类型层面"编程"，即用类型系统来解决实际问题如实现 Deep Readonly、Omit 甚至 Promise.all 等。我们从演变、原理和场景三个维度作为切入点：

1. 类型能力的演变

| 阶段         | 特征             | TS 版本 | 关键能力                   |
| ------------ | ---------------- | ------- | -------------------------- |
| 基础类型     | 简单类型标注     | 1.0+    | 接口、联合类型             |
| 泛型编程     | 参数化类型       | 2.0+    | 泛型约束、条件类型         |
| 类型元编程   | 类型层面逻辑运算 | 4.1+    | 模板字面量类型、递归类型   |
| 类型图灵完备 | 模拟任意计算     | 4.8+    | 深度模式匹配、类型级控制流 |

2. 图灵完备的证明（只是编译阶段）

通过实现类型层面的 SKI 组合子演算：

```ts
type S = <A, B, C>(x: A, y: B, z: C) => (x & z) & (y & z);
type K = <A, B>(x: A) => (_: B) => A;
type I = <A>(x: A) => A;
type SKK = S<K, K>;  // 等价于 I 组合子
```

3. 底层原理：

- 逻辑运算：`extends ? :`（条件类型）
- 结构操作：`keyof`、`T[K]` 和 `infer`
- 集合运算：`|` 并 `&` 交
- 递归控制：尾递归优化（TS 4.5+）

类型推导引擎工作流程：

```
A[源码类型标注] --> B[类型解析器] --> C[无需泛型推断] ? D[直接类型检查] : E[创建类型变量] --> F[构建约束系统] --> G[解方程算法] --> H[类型实例化] --> I[类型一致性验证]
```
