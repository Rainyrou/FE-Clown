###### 编译

JavaScript 不要求变量有明确的数据类型定义，允许动态访问和修改属性，此种灵活性在小型项目中提高我们的开发效率，但随着项目规模、变量数量和数据类型的增加，此种灵活性成为某种隐患如访问未定义的属性或调用非函数类型。TypeScript 提供类型系统解决上述问题如严格模式 + 静态类型注解 + 赋值和函数返回类型自动推断 + 泛型约束 + 接口定义及类型别名 + 类型断言 + 类型守卫 + 内置工具类型，类型系统在开发时进行数据类型检查而不必等到运行时，有助于在开发早期发现潜在错误，确保代码中的数据类型符合预期，减少心智负担，且 TypeScript 最终转换为 JavaScript ，不影响程序的运行时性能

TypeScript 编译器在浏览器或 Node.js 解析 `.ts` 或 `.tsx` 文件，将源代码转换为表示源代码结构的深层嵌套对象的 AST，其包括语法元素及其属性如变量声明、函数调用、类和接口等，判断数据类型、数据类型的兼容性、类型注解和类型推断是否正确，若出现错误则输出错误并停止编译，再将 AST 转换为与目标 JavaScript 版本兼容的 JavaScript 代码，如将 ES6 的类转换为 ES5 的函数和原型，移除所有 TypeScript 类型注解，最终将新的 AST 转换为可执行的 JavaScript 代码字符串并将其写入 `.js` 文件

###### 类型体操

TypeScript 的「类型体操」概念源于其图灵完备的类型系统，其为一种工程化的防御手段，随项目对类型安全要求越来越高，前端开始探索如何在类型层面"编程"，即用类型系统来解决实际问题如实现 Deep Readonly、Omit 甚至 Promise.all 等。我们从演变、原理和场景三个维度作为切入点：

1. 类型能力的演变

| 阶段     | 特征       | TS 版本 | 关键能力          |
| ------ | -------- | ----- | ------------- |
| 基础类型   | 简单类型标注   | 1.0+  | 接口、联合类型       |
| 泛型编程   | 参数化类型    | 2.0+  | 泛型约束、条件类型     |
| 类型元编程  | 类型层面逻辑运算 | 4.1+  | 模板字面量类型、递归类型  |
| 类型图灵完备 | 模拟任意计算   | 4.8+  | 深度模式匹配、类型级控制流 |
|        |          |       |               |

2. 图灵完备的证明（只是编译阶段）

通过实现类型层面的 SKI 组合子演算：

```ts
type S = <A, B, C>(x: A, y: B, z: C) => (x & z) & (y & z);
type K = <A, B>(x: A) => (_: B) => A;
type I = <A>(x: A) => A;
type SKK = S<K, K>;  // 等价于 I 组合子
```

3. 底层原理：

- 逻辑运算：`extends ? :`（条件类型）
- 结构操作：`keyof`、`T[K]` 和 `infer`
- 集合运算：`|` 并 `&` 交
- 递归控制：尾递归优化（TS 4.5+）

类型推导引擎工作流程：

```
A[源码类型标注] --> B[类型解析器] --> C[无需泛型推断] ? D[直接类型检查] : E[创建类型变量] --> F[构建约束系统] --> G[解方程算法] --> H[类型实例化] --> I[类型一致性验证]
```
