- 明确需求：系统梳理垃圾回收核心逻辑，对比早期与现代方案差异，聚焦 V8 引擎新老生代算法的适配逻辑，兼顾原理与实践场景
- 核心前提：垃圾回收的本质是「自动识别并释放不可用对象的内存」，在回收效率和程序暂停时间取得trade-off，避免手动管理内存的泄漏风险
- 早期方案：引用计数算法 —— 以「对象的引用次数」为核心，引用时计数 + 1，释放时计数 - 1，计数为 0 则释放内存，优势是实现简单，劣势是无法解决循环引用问题
- 现代方案：标记清除算法 —— 以「对象的可达性」为核心，分两阶段执行，标记阶段：GC 暂停程序执行，以根对象为起点遍历所有关联对象，设置可访问对象的标记位为  1；清除阶段：遍历整个堆内存，将标记位为 0 的不可达对象释放，其内存地址添加至空闲内存链表，最后重置存活对象的标记位为 0，恢复程序执行，该方案彻底解决循环引用问题，是现代编程语言GC 引擎的核心
- 优化策略：为解决标记清除算法的「暂停程序时间过长」和「内存碎片」的问题，进行以下优化：① 分代回收：基于大多数对象生命周期短的经验法则，拆分新老生代；② 增量标记：将标记阶段拆分为多个小步骤，穿插于程序执行中，减少单次暂停程序耗时
- V8 引擎：深度结合上述方案，适配 JavaScript 对象的生命周期特征：① 新生代：存储短生命周期对象，通过 Scavenge 算法，将堆内存拆分为 From 和 To 两个半区，标记存活对象并复制到 To 区，清空 From 区后互换角色，核心是「以空间换时间」，回收效率高，但以一半内存空间为代价；② 老生代：存储长生命周期对象，经过多次回收仍存活的JavaScript 对象为老生代，通过标记清除为主、标记整理为辅的策略 —— 标记清除策略能快速移除不可达对象，但会产生内存碎片，而标记整理策略定期将存活对象向堆内存一端移动，整理碎片，平衡空间利用率与回收效率
- 逻辑闭环：综上现代 GC 以「对象的可达性」为基础，通过「分代回收 + 增量标记」解决「暂停程序时间过长」和「内存碎片」的问题，V8 则针对新老生代对象的生命周期差异，通过不同算法实现 JavaScript 运行时的高效内存管理


