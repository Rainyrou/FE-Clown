1. 垃圾：当程序中的对象不再被任何变量引用，或无法通过引用获得时，该对象被视为垃圾
2. 引用计数：每个对象都有一个引用计数，表示引用该对象的变量数量。当计数减少到零时，即该对象不再被引用，它的内存就会被回收。但引用计数有一个致命缺陷：循环引用。如果两个对象相互引用，且它们都不再被外部引用，但它们的引用计数永不为零，从而导致内存泄漏
3. 标记-清除：在标记阶段，从根开始遍历所有对象并标记活动的对象。在清除阶段，未标记的对象被视为垃圾，并被回收
4. 标记-压缩：与标记-清除类似，但在清除阶段，它还会将存活的对象压缩到一起，减少内存碎片
5. 分代回收：这种策略基于观察，大多对象很快就会死亡，但另外一些存在较长时间。将内存分为几代，新对象被划分为最年轻的一代。当垃圾回收运行时，它优先考虑那些年轻的对象。只有在这些对象存活足够长的时间后，它们才会被被划分为更老的一代
6. JavaScript 使用了标记-清除策略。从全局对象（如 `window`）开始，垃圾收集器标记所有可访问的对象，然后清除所有未标记的对象
7. 尽管有了垃圾回收，但仍可能出现内存泄漏。这是因为开发者在对象中保留了不再需要的引用，导致它们没有被回收
8. 一些编程语言（如 C 和 C++）依赖于开发者手动分配和释放内存，这提供了更强大的机制，但也增加了内存泄漏的风险。相反，JavaScript 和 Java选择垃圾回收机制
