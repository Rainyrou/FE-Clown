搭建 Node 服务端：

- 初始化项目：`npm init -y`
- 安装依赖（服务端框架、路由、请求体解析器和请求日志）
- 在主文件中引入所有依赖并创建服务端应用实例，注册全局中间件（错误处理/日志/跨域/请求体解析），路由层定义路由 + 按业务模块拆分路由 -> 创建路由实例 -> 定义接口，控制器取参 -> 校验参数合法性 -> 调用服务层 -> 返回结果，服务层调用数据层 -> 处理业务逻辑 -> 返回结果，数据层初始化 -> 对数据增删改查 -> 返回结果，启动路由和服务端

设计 BFF：

- 设计原则：API 设计以前端页面和组件需求为导向而非后端微服务接口结构，BFF 层解耦前后端，进行接口聚合、数据适配、路由与版本控制、权限验证和简单业务逻辑而无需复杂计算，后端微服务重构、扩展和接口修改时，只需修改 BFF 层适配逻辑，前端无需感知
- 接口聚合：BFF 层接收到前端单个请求后，并行调用多个依赖的微服务接口，通过缓存或请求池合并同一请求，聚合返回结果
- 数据适配：BFF 层通过字段映射、数据过滤、格式标准化将多个微服务返回的结果转换为前端友好型数据
- 路由与版本控制：通过 RESTful 格式 + 资源导向设计路由以适配前端业务场景，通过 URL 或请求头部字段实现版本控制
* 权限验证：BFF 层为前端请求的唯一入口，验证用户身份、接口访问权限和参数，内置接口限流，防止 XSS & SQL Injection & CSRF & MITM & DDoS 攻击
* 缓存分层设计：一级缓存 -> 本地内存缓存，二级缓存 -> 分布式缓存，三级缓存 -> CDN 缓存
* 缓存粒度设计：通过粗粒度缓存不频繁变化和高频访问的 API（缓存整个 API 的返回结果 + key 为 API 路径和请求参数） ，通过细粒度缓存频繁变化和聚合逻辑复杂的 API（缓存单个微服务接口的返回结果 + key 为微服务接口名和请求参数）
* 缓存失效与更新机制：过期时间失效 -> 通过设置缓存 key 的过期时间，过期后重新加载微服务数据；事件驱动失效 -> 通过消息队列发送事件，BFF 层监听事件后删除对应缓存 key；定时任务更新 -> 通过定时任务定期调用微服务接口，更新缓存数据
* 缓存穿透/击穿/雪崩
