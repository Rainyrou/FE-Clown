###### 原因

1. 二进制浮点数表示法：计算机内部表示数字时使用的是二进制。某些十进制小数如 0.1 在转换为二进制时得到一个无限循环的小数，这种小数在存储时被截断，从而导致精度丢失如 `0.1` 在二进制中表示为 `0.000110011001100110011001100...`
2. 有限的存储空间：JavaScript 使用 64 位双精度浮点数格式来表示数字，在 64 位中，1 位表示符号，11 位表示指数，52 位表示小数部分。由于空间有限，超出这 52 位的部分被截断

###### 常见场景

1. 浮点数加减：

```JavaScript
console.log(0.1 + 0.2); // 0.30000000000000004
```

2. 大数字丢失精度：大于 `Number.MAX_SAFE_INTEGER`（`9007199254740991`）或小于 `Number.MIN_SAFE_INTEGER`（`-9007199254740991`）的整数在进行数学运算时丢失精度

```JavaScript
console.log(9007199254740992 === 9007199254740993); // true
```

###### 解决方案

1. 避免直接使用浮点数计算
2. 使用像 BigInt 或 decimal.js、math.js 等库计算
3. 使用 `toFixed` 方法对计算结果进行四舍五入

```JavaScript
const result = (0.1 + 0.2).toFixed(2);
console.log(result); // 0.30
```
