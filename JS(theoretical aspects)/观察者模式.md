Observer Pattern 定义对象间的依赖关系，当一个对象的状态变化时，所有依赖于它的对象均得到通知并自动更新。观察者订阅某主题，当主题状态发生变化，主题遍历所有观察者，并逐一通知它们，观察者在接到通知后执行某些操作

优点:

- 支持低耦合设计，主题和观察者可独立变化
- 主题和观察者间的关系动态，可在运行时增删观察者
- 表示层和数据逻辑层分离，定义消息更新传递机制，抽象更新接口

不足:

- 若一个主题有大量观察者，通知所有观察者耗费大量时间
- 若观察者和观察目标间有循环依赖，观察目标触发循环调用
- 无相应机制让观察者知道所观察的目标对象发生变化的细节，仅仅通知观察目标发生变化

```JavaScript
class Subject {
  constructor() {
    this.observers = [];
  }
  addObserver(observer) {
    this.observers.push(observer);
  }
  removeObserver(observer) {
    const index = this.observers.indexOf(observer);
    if (index > -1) this.observers.splice(index, 1);
  }
  notify(data) {
    this.observers.forEach((observer) => observer.update(data));
  }
}

class Observer {
  update(data) {
    console.log(`receive data: ${data}`);
  }
}
```

测试用例：

```JavaScript
const subject = new Subject();
const observer1 = new Observer();
const observer2 = new Observer();

subject.addObserver(observer1);
subject.addObserver(observer2);
subject.notify('Hello world!');
subject.removeObserver(observer1);
subject.notify('Goodbye world!');
```

正确输出：

![[1697670839501.png]]
