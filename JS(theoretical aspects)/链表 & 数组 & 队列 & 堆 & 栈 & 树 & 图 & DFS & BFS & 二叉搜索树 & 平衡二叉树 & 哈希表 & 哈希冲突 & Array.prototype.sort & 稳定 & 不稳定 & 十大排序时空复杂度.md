数组：数组元素根据顺序依次存储，通过起点和索引计算元素索引，因此查找元素时间复杂度为 O(1)，增删元素需移动目标元素前后元素，因此增删元素的时间复杂度为 O(n)
链表： JavaScript 无内置链表，通过对象模拟，链表元素存储于内存的任意位置，各个节点均包含值及指向下一节点的引用，访问元素需遍历链表，因此查找元素时间复杂度为 O(n)，增删元素需改变其前后节点引用，因此增删元素的时间复杂度为 O(1)
队列：先进先出，在一端增加元素，在另一端删除元素
栈：后进先出，大小确定，调用函数时，函数变量和参数推至栈中，函数执行完后弹出，控制权返回函数调用者
堆：大小不确定，动态分配内存，较强的灵活性，较慢的读写速度
树：从根节点开始，通过边访问各个节点，各个节点只有一个父节点（除根节点外）和零到多个子节点，n 个节点有 n-1 条边
图：多对多，节点可访问且无固定起始节点，有/无环，有/无向，连通/不连通，边有/无权重
BFS：从根节点开始层层遍历节点
DFS：从根节点开始遍历某分支直至找到叶子节点，回溯后遍历其他分支
二叉搜索树：任意节点的左子树所有节点值均小于，右子树所有节点值均大于，所有子节点均为二叉搜索树
平衡二叉树：继承二叉搜索树性质，高度差小于等于 1
哈希表：哈希桶数组，一块连续的内存空间，内存地址从数组起始地址开始线性分布，数组各个元素为桶入口，其内存大小固定
哈希冲突：哈希表或哈希映射存储键值对，不同键通过哈希函数获取同一哈希值即不同键位于同一索引

- 开放寻址法：根据某种顺序检测其他位置并存储键值对
- 链表法：同一哈希值的元素添加于同一链表中

`Array.prototype.sort` 在 ES10 前为不稳定排序，在 ES10 后为稳定排序，将元素转换为字符串形式再比较，若提供比较函数，则通过该函数返回值决定元素间的排序关系

1. V8 引擎（Chrome, Node.js）：插入排序 -> 小于等于 10 个元素数组，快排 + Timsort -> 大于 10 个元素数组
2. SpiderMonkey（Firefox）& JavaScriptCore（Safari）：归并排序

若相等元素在排序前后保持同一相对顺序，则为稳定排序如冒泡、插入和归并等
若相等元素在排序前后改变其相对顺序，则为不稳定排序如快排，快排的不稳定性源于分区，相等元素根据其遭遇基准的顺序移至基准的某侧，可能改变其初始相对顺序

时间复杂度：O(2^n) -> 斐波那契数列递归

1. 冒泡排序：

- 时间复杂度：最好情况 -> O(n) + 数组有序，最坏情况 -> O(n²) + 数组逆序，平均情况 -> O(n²)

* 空间复杂度：O(1) -> 原地排序

2. 选择排序：

- 时间复杂度：最好/最坏/平均情况 -> O(n²) + n-1 次选择

* 空间复杂度：O(1) -> 原地排序

3. 插入排序：

- 时间复杂度：最好情况 -> O(n) + 数组有序，最坏情况 -> O(n²) + 数组逆序，平均情况 -> O(n²)

* 空间复杂度：O(1) -> 原地排序

4. 快速排序：

- 时间复杂度：最好/平均情况 -> O(n log n) ，最坏情况 -> O(n²) + 基准为最小/大元素

* 空间复杂度：O(log n)/O(n) -> 递归深度

5. 归并排序：

- 时间复杂度：最好/最坏/平均情况 -> O(n log n) + 遍历所有元素并合并

* 空间复杂度：O(n) -> 创建与原数组大小相同的新数组合并分组

6. 希尔排序：

- 时间复杂度：最好情况 -> O(n log n) + 间隔序列，最坏情况 -> O(n(log n)²)

* 空间复杂度：O(1) -> 原地排序

7. 堆排序

- 时间复杂度：最好/最坏/平均情况 -> O(n log n)

* 空间复杂度：O(1) -> 原地排序

8. 桶排序

- 时间复杂度：最好情况 -> O(n+k) ，最坏情况 -> O(n²) + 所有元素分配于同一桶，平均情况 -> O(n+k)

* 空间复杂度：O(n+k)

9. 计数排序

- 时间复杂度：最好/最坏/平均情况 -> O(n+k) + k 为输入数据的范围

* 空间复杂度：O(k)

10. 基数排序

- 时间复杂度：最好/最坏/平均情况 -> O(nk) + k 为数字的最大位数

* 空间复杂度：O(n+k)
