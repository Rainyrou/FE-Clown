JavaScript 函数在创建时，它将周围的作用域捕获到自己的环境中，并推入执行上下文栈，形成一个词法环境，当函数访问不属于自己局部作用域内的变量时，它从该词法环境查找，若没找到，继续在链上的外部词法环境中查找，直到找到该变量或查找完全局环境为止。闭包是函数与其词法作用域的组合，允许你访问定义在函数外部的词法作用域

1. 封装函数内部状态，实现数据私有化，其不能直接从外部访问，是模块模式的基础，类似于传统面向对象语言中的私有属性和私有方法
2. 保留状态，即便其词法作用域已执行完毕，内部函数仍可访问外部函数中的变量
3. 函数柯里化：利用闭包实现函数柯里化

###### 注意事项

- 内存管理：闭包保留对外部函数中变量的引用，导致内存泄漏
- 性能考量：闭包保留其词法作用域

###### 实现

1. 在一个函数内部定义另一函数，内嵌函数引用外部函数中的变量，外部函数返回该内嵌函数
2. 在对象方法中定义并使用内部函数，这些内部函数可以访问定义它们的作用域中的变量
3. 通过立即执行函数表达式创建私有作用域，内部变量对外部是不可见的，但可通过特定函数访问它们

###### 闭包变量不被回收

因为闭包保留其词法作用域，外部函数中的变量仍被内部函数引用，引用计数不为 0

```JavaScript
function createCounter() {
  let count = 0;
  return {
    increase: function() {
      count++;
      return count;
    },
    getCount: function() {
      return count;
    }
  };
}

const counter = createCounter();
console.log(counter.increase()); // 1
console.log(counter.getCount()); // 1
```
