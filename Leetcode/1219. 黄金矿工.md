[1219. 黄金矿工](https://leetcode.cn/problems/path-with-maximum-gold/description/)

```javascript
var getMaximumGold = function (grid) {
  const m = grid.length,
    n = grid[0].length;
  const dirs = [
    [-1, 0],
    [0, 1],
    [1, 0],
    [0, -1],
  ];
  let ans = 0;
  const dfs = (i, j, curSum) => {
    if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] === 0) return;
    curSum += grid[i][j];
    const temp = grid[i][j];
    grid[i][j] = 0;
    ans = Math.max(ans, curSum);
    for (const dir of dirs) {
      const x = i + dir[0],
        y = j + dir[1];
      dfs(x, y, curSum);
    }
    grid[i][j] = temp;
  };
  for (let i = 0; i < m; ++i) {
    for (let j = 0; j < n; ++j) {
      if (grid[i][j] !== 0) dfs(i, j, 0);
    }
  }
  return ans;
};
```

```javascript
var getMaximumGold = function (grid) {
  const m = grid.length,
    n = grid[0].length;
  const dirs = [
    [-1, 0],
    [0, 1],
    [1, 0],
    [0, -1],
  ];
  let ans = 0;
  const dfs = (i, j) => {
    if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] === 0) return 0;
    const gold = grid[i][j];
    grid[i][j] = 0;
    let curMax = 0;
    for (const dir of dirs) {
      const x = i + dir[0],
        y = j + dir[1];
      curMax = Math.max(curMax, dfs(x, y));
    }
    grid[i][j] = gold;
    return gold + curMax;
  };
  for (let i = 0; i < m; ++i) {
    for (let j = 0; j < n; ++j) {
      if (grid[i][j] !== 0) ans = Math.max(ans, dfs(i, j));
    }
  }
  return ans;
};
```