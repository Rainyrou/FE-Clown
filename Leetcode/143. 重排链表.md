[143. 重排链表](https://leetcode.cn/problems/reorder-list/description/)

```javascript
var reorderList = function(head) {
  const mid = middleNode(head);
  let head2 = reverseList(mid), next = null, next2 = null;
  while(head2.next) {
  L0→L1→L2→L3→L4
    next = head.next; 
    next2 = head2.next;
    head.next = head2; 
    head2.next = next; 
    head = next; 
    head2 = next2; 
  }
};

const reverseList = head => {
  let cur = head, pre = null, next = null;
  while(cur) {
    next = cur.next;
    cur.next = pre;
    pre = cur;
    cur = next;
  }
  return pre;
}

const middleNode = head => {
  let dummyHead = new ListNode(-1, head), slow = dummyHead, fast = dummyHead;
  while(fast.next && fast.next.next) {
    fast = fast.next.next;
    slow = slow.next;
  }
  return slow.next;
}
```

在合并阶段，我们需要交替选择 `head`（前半部分）和 `head2`（反转后的后半部分）的节点进行拼接，而 `while (head2.next)` 可以避免最后两个节点重复连接

- 链表长度为偶数：`L0→L1→L2→L3`，中点为 `L2`，反转后半部分后 `head2` 是 `L3→L2`，循环执行时，`head2.next` 初始为 `L2`（非空），执行一次拼接后，`head2` 会变成 `L2`，此时 `head2.next` 为空，循环结束。
- 链表长度为奇数：`L0→L1→L2→L3→L4`，中点为 `L2`，反转后半部分后 `head2` 是 `L4→L3→L2`，循环执行时，`head2.next` 初始为 `L3`（非空），执行两次拼接后，`head2` 为 `L2`，此时 `head2.next` 为空，循环结束

```dart
class Solution {
  void reorderList(ListNode? head) {
    if(head == null || head.next == null) return;
    ListNode? mid = middleNode(head);
    ListNode? head2 = reverseList(mid), next = null, next2 = null;
    while(head2 != null && head2.next != null) {
      next = head!.next;
      next2 = head2.next;
      head.next = head2;
      head2.next = next;
      head = next;
      head2 = next2;
    }
  }
  ListNode? reverseList(ListNode? head) {
    ListNode? cur = head, pre = null, next = null;
    while(cur != null) {
      next = cur.next;
      cur.next = pre;
      pre = cur;
      cur = next;
    }
    return pre;
  }
  ListNode? middleNode(ListNode? head) {
    ListNode? dummyHead = ListNode(-1, head), slow = dummyHead, fast = dummyHead;
     while (fast?.next != null && fast?.next?.next != null) {
      fast = fast?.next?.next;
      slow = slow?.next;  
    }
    return slow?.next;
  }
}
```

```python
class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        mid = self.middleNode(head)
        head2 = self.reverseList(mid)
        while head2 and head2.next:
          next = head.next
          next2 = head2.next
          head.next = head2
          head2.next = next
          head = next
          head2 = next2
    
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
      cur, pre, next = head, None, None
      while cur:
        next = cur.next
        cur.next = pre
        pre = cur
        cur = next
      return pre
    
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
      dummyHead = ListNode(-1, head)
      slow, fast = dummyHead, dummyHead
      while fast.next and fast.next.next:
        fast = fast.next.next
        slow = slow.next
      return slow.next
```