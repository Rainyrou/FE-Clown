[LRU 缓存](https://leetcode.cn/problems/lru-cache/)

Least Recently Used 即"最近最少使用"策略是一种缓存淘汰策略，当缓存达到上限时，它优先删除最近最久未使用的数据，确保快速获取最近使用的数据，而替换久未使用的数据

```js
class LRUCache {
  constructor(n, x) {
    this.map = new Map();
    this.capacity = n;
    this.timeout = x * 1000;
  }
  get(id) {
    const entry = this.map.get(id);
    if (!entry) return -1;
    if (entry.expires < Date.now()) {
      this.map.delete(id);
      return -1;
    }
    this.map.delete(id);
    this.map.set(id, {
      object: entry.object,
      expires: Date.now() + this.timeout,
    });
    return entry.object;
  }
  set(id, object) {
    if (this.map.has(id)) this.map.delete(id);
    this.map.set(id, { object, expires: Date.now() + this.timeout });
    if (this.map.size > this.capacity)
      this.map.delete(this.map.keys().next().value);
  }
}

const cache = new LRUCache(3, 5);
cache.set(1, "a");
cache.set(2, "b");
console.log(cache.get(1)); // a
setTimeout(() => console.log(cache.get(1)), 6000); // -1 超时被清理
cache.set(3, "c");
cache.set(4, "d");
console.log(cache.get(2)); // -1 被 LRU 删除
cache.set(5, "e");
console.log(cache.get(3)); // c
```

###### Map

```javascript
var LRUCache = function (capacity) {
  this.map = new Map();
  this.capacity = capacity;
};

LRUCache.prototype.get = function (key) {
  if (!this.map.has(key)) return -1;
  const value = this.map.get(key);
  this.map.delete(key);
  this.map.set(key, value);
  return value;
};

LRUCache.prototype.put = function (key, value) {
  if (this.map.has(key)) this.map.delete(key);
  this.map.set(key, value);
  if (this.map.size > this.capacity)
    this.map.delete(this.map.keys().next().value);
};
```

