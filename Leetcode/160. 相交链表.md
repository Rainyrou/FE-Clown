[相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&envId=top-100-liked)

错误解法：

```js
var getIntersectionNode = function (headA, headB) {
  let p1 = headA,
    p2 = headB;
  while (p1 !== p2) {
    p1 = p1.next ? p1.next : headB;
    p2 = p2.next ? p2.next : headA;
  }
  return p1;
};
```

这种做法在两个链表不存在相交节点且长度相等时出现无限循环，而正确做法为在指针移至链表尾部且判断为空后才将其移至另一链表头部

双指针 1：

```javascript
var getIntersectionNode = function (headA, headB) {
  let p1 = headA,
    p2 = headB;
  while (p1 !== p2) {
    p1 = p1 === null ? headB : p1.next;
    p2 = p2 === null ? headA : p2.next;
  }
  return p1;
};
```

双指针 2：

```JavaScript
const getLen = head => {
  let len = 0, cur = head;
  while(cur) {
    len++;
    cur = cur.next;
  }
  return len;
}

var getIntersectionNode = function(head1, head2) {
  let p1 = head1, p2 = head2, len1 = getLen(head1), len2 = getLen(head2);
  if(len1 < len2) {
    [p1, p2] = [p2, p1];
    [len1, len2] = [len2, len1];
  }
  let i = len1 - len2;
  while(i-- > 0) p1 = p1.next;
  while(p1 && p1 !== p2) p1 = p1.next, p2 = p2.next;
  return p1;
};
```

哈希表

```javascript
var getIntersectionNode = function(head1, head2) {
  const set = new Set();
  while(head1) {
    set.add(head1);
    head1 = head1.next;
  }
  while(head2) {
    if(set.has(head2)) return head2;
    head2 = head2.next;
  }
  return null;
};
```

