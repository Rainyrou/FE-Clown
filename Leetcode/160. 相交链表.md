[相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&envId=top-100-liked)

错误解法：

```js
var getIntersectionNode = function (headA, headB) {
  let p1 = headA,
    p2 = headB;
  while (p1 !== p2) {
    p1 = p1.next ? p1.next : headB;
    p2 = p2.next ? p2.next : headA;
  }
  return p1;
};
```

这段代码的问题在于，当链表无交点且两个链表的长度相等时，陷入无限循环。正确的做法应该是在指针到达末尾后才将其重定向至另一链表头部

双指针 1

```javascript
var getIntersectionNode = function (headA, headB) {
  let p1 = headA,
    p2 = headB;
  while (p1 !== p2) {
    p1 = p1 === null ? headB : p1.next;
    p2 = p2 === null ? headA : p2.next;
  }
  return p1;
};
```

双指针 2

```JavaScript
const getLen = head => {
  let len = 0, cur = head;
  while(cur) {
    len++;
    cur = cur.next;
  }
  return len;
}

var getIntersectionNode = function(head1, head2) {
  let p1 = head1, p2 = head2, len1 = getLen(head1), len2 = getLen(head2);
  if(len1 < len2) {
    [p1, p2] = [p2, p1];
    [len1, len2] = [len2, len1];
  }
  let i = len1 - len2;
  while(i-- > 0) p1 = p1.next;
  while(p1 && p1 !== p2) p1 = p1.next, p2 = p2.next;
  return p1;
};
```

哈希表

```javascript
var getIntersectionNode = function(head1, head2) {
  const set = new Set();
  while(head1) {
    set.add(head1);
    head1 = head1.next;
  }
  while(head2) {
    if(set.has(head2)) return head2;
    head2 = head2.next;
  }
  return null;
};
```

