[162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/description/)

indexOf：

```javascript
var findPeakElement = function(nums) {
  return nums.indexOf(Math.max(...nums));
};
```

一次遍历：

```javascript
var findPeakElement = function(nums) {
  let index = 0;
  for(let i = 1;i < nums.length;++i) if(nums[index] < nums[i]) index = i;
  return index;
};
```

二分：

- 题意有对于所有有效的  `i`  都有  `nums[i] != nums[i + 1]`，因此下面的条件判断语句 `nums[mid] === nums[mid+1]` 的情况根本不可能发生！
- 当 `nums[mid] > nums[mid + 1]` 时，我们设置 `right = mid - 1` 并不会遗漏峰值为 `nums[mid]` 的情况，因为若为此种情况，`right` 为 `mid - 1`，此时 `left === right === newMid`，由于下一阶段我们仍比较 `nums[newMid]` 和 `nums[newMid + 1] === nums[mid]` 的大小，此时 `left = newMid + 1 === mid`
- `left === right` 进入 while 循环保证通过循环内的逻辑处理最后一个元素的情况，而无需在依赖循环外单独处理

```javascript
var findPeakElement = function(nums) {
  let left = 0, right = nums.length - 1;
  while(left <= right) {
    const mid = Math.floor((right - left) / 2) + left;
    if(nums[mid] < nums[mid + 1]) left = mid + 1;
    else right = mid - 1;
  }
  return left;
};
```
