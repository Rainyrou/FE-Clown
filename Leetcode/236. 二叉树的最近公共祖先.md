[二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

###### 递归

```javascript
class TreeNode {
  constructor(val) {
    this.val = val || null;
    this.left = null;
    this.right = null;
  }
}

const buildTree = (arr) => {
  if (!arr || !arr.length) return null;
  const nodes = arr.map((val) =>
    val !== null && val !== undefined ? new TreeNode(val) : null
  );
  for (let i = 0; i < nodes.length; i++) {
    if (!nodes[i]) continue;
    const leftIndex = i * 2 + 1,
      rightIndex = i * 2 + 2;
    if (leftIndex < nodes.length) nodes[i].left = nodes[leftIndex];
    if (rightIndex < nodes.length) nodes[i].right = nodes[rightIndex];
  }
  return nodes[0];
};

const findNode = (root, val) => {
  if (!root) return null;
  if (root.val === val) return root;
  return findNode(root.left, val) || findNode(root.right, val);
};

var lowestCommonAncestor = function (root, p, q) {
  if (!root || p === root || q === root) return root;
  const left = lowestCommonAncestor(root.left, p, q);
  const right = lowestCommonAncestor(root.right, p, q);
  return left && right ? root : left || right;
};

const root = [3, 5, 1, 6, 2, 0, 8, null, null, 7, 4],
  p = 5,
  q = 1;
const root1 = buildTree(root),
  pNode = findNode(root1, 5),
  qNode = findNode(root1, 1);
const ans1 = lowestCommonAncestor(root1, pNode, qNode);
console.log(ans1.val); // 3
```

###### 父指针迭代

```JavaScript
var lowestCommonAncestor = function(root, p, q) {
  const parent = new Map();
  const stk = [root];
  parent.set(root, null);
  while(!parent.has(p) || !parent.has(q)) {
    const node = stk.pop();
    if(node.left) {
      parent.set(node.left, node);
      stk.push(node.left);
    }
    if(node.right) {
      parent.set(node.right, node);
      stk.push(node.right);
    }
  }
  const ancestors = new Set();
  while(p) {
    ancestors.add(p);
    p = parent.get(p);
  }
  while(!ancestors.has(q)) q = parent.get(q);
  return q;
};
```