[257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/description/)

```javascript
class TreeNode {
  constructor(val) {
    this.val = val;
    this.left = null;
    this.right = null;
  }
}

const buildTree = (arr) => {
  if (!arr || !arr.length) return null;
  const nodes = arr.map((val) =>
    val !== null && val !== undefined ? new TreeNode(val) : null
  );
  for (let i = 0; i < nodes.length; i++) {
    if (!nodes[i]) continue;
    const leftIndex = 2 * i + 1;
    const rightIndex = 2 * i + 2;
    if (leftIndex < nodes.length) nodes[i].left = nodes[leftIndex];
    if (rightIndex < nodes.length) nodes[i].right = nodes[rightIndex];
  }
  return nodes[0];
};

var binaryTreePaths = function (root) {
  const ans = [];
  const buildPath = (root, pathStr) => {
    if (!root) return;
    if (!root.left && !root.right) {
      pathStr += root.val;
      ans.push(pathStr);
      return;
    }
    pathStr += root.val + "->";
    buildPath(root.left, pathStr);
    buildPath(root.right, pathStr);
  };
  buildPath(root, "");
  return ans;
};

const root = [1, 2, 3, null, 5];
console.log(binaryTreePaths(buildTree(root)));
```

```javascript
var binaryTreePaths = function (root) {
  const ans = [];
  const dfs = (node, path) => {
	path.push(node.val);
    if (!node.left && !node.right) {
      ans.push(path.join("->"));
      return;
    }
    if (node.left) dfs(node.left, path.slice());
    if (node.right) dfs(node.right, path.slice());
  };
  dfs(root, []);
  return ans;
};
```