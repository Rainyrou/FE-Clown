[297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/description/)

###### DFS

```javascript
var serialize = function (root) {
  if (!root) return "X";
  const left = serialize(root.left),
    right = serialize(root.right);
  return root.val + "," + left + "," + right;
};

var deserialize = function (data) {
  const arr = data.split(",");
  const buildTree = (arr) => {
    const rootVal = arr.shift();
    if (rootVal === "X") return null;
    const root = new TreeNode(Number(rootVal));
    root.left = buildTree(arr);
    root.right = buildTree(arr);
    return root;
  };
  return buildTree(arr);
};
```

###### BFS

```javascript
var serialize = function(root) {
  const queue = [root], ans = [];
  while(queue.length) {
    const cur = queue.shift();
    if(cur) {
      ans.push(cur.val);
      queue.push(cur.left);
      queue.push(cur.right);
    } else {
      ans.push('X');
    }
  }
  return ans.join(',')
};

var deserialize = function(data) {
  if(data === 'X') return null;
  const list = data.split(',');
  const root = new TreeNode(parseInt(list[0], 10));
  const queue = [root];
  let index = 1;
  while(index < list.length) {
    const cur = queue.shift();
    const leftVal = list[index], rightVal = list[index + 1];
    if(leftVal !== 'X') {
      const leftNode = new TreeNode(parseInt(leftVal, 10));
      cur.left = leftNode;
      queue.push(leftNode);
    } 
    if(rightVal !== 'X') {
      const rightNode = new TreeNode(parseInt(rightVal, 10));
      cur.right = rightNode;
      queue.push(rightNode);
    }
    index += 2;
  }
  return root;
};
```
