[440. 字典序的第 K 小数字](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/description/)

```javascript
var findKthNumber = function (n, k) {
  const getCount = (node) => {
    let count = 0,
      left = node,
      right = node + 1;
    while (left <= n) {
      count += Math.min(right, n + 1) - left; // n + 1 -> right 为开区间
      left *= 10;
      right *= 10;
    }
    return count;
  };
  let node = 1;
  --k;
  while (k) {
    const count = getCount(node);
    if (count <= k) { // 第 k 个节点不在当前子树中
      ++node; // 跳过当前子树，向右移动至兄弟节点
      k -= count; // 减去当前子树的节点数
    } else {
      node *= 10; // 向下移动至首个子节点
      --k; // 减去当前节点本身
    }
  }
  return node;
};
```

- 字典序根据字符/数字顺序逐位比较排序，十进制数字的各位均有 0-9 十个可能取值，匹配字典序前缀扩展的规则
- 将 [1, n] 的字典序排序等价于以 1-9 为根（数字从 1 开始）的 10 叉树的前序遍历，各个节点的子节点为「节点值 ×10」「节点值 ×10+1」…「节点值 ×10+9」，通过计算当前节点的子树大小判断第 k 个节点是否在当前子树中，若不存在则直接跳过当前子树（剪枝），否则在当前子树中查找
- `getCount` 计算在以  `node`  为根节点的子树中 ≤n 的节点总数，10 叉树节点按层分布，各层节点范围为  `[left, right)`，第 0 层为 `node` 本身
- 初始化 `--k`，剩余位置 k -> 0 - based，`k = 0` 即当前节点
- `count ≤k`，子树索引范围为「0 ~ count - 1」，若 `k ≥ count` → 目标索引超出子树索引范围
- 字典序 + 十叉树的时间复杂度 O (log²n)，堆排序的时间复杂度为 O(k log m)，m 为堆大小如 10
