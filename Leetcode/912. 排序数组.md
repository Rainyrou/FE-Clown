[排序数组](https://leetcode.cn/problems/sort-an-array/)

最大堆：

```javascript
var sortArray = function(nums) {
  let heapSize = nums.length;
  buildMaxHeap(nums, heapSize);
  for(let i = nums.length - 1;i > 0;--i) {
    [nums[i], nums[0]] = [nums[0], nums[i]];
    --heapSize;
    maxHeapify(0, nums, heapSize);
  }  
  return nums;
};

const buildMaxHeap = (nums, heapSize) => {
  for(let i = (heapSize >> 1) - 1;i >= 0;--i) maxHeapify(i, nums, heapSize);
}

const maxHeapify = (i, nums, heapSize) => {
  let largest = i;
  while(i < heapSize) {
    let left = i * 2 + 1, right = i * 2 + 2;
    if(left < heapSize && nums[largest] < nums[left]) largest = left;
    if(right < heapSize && nums[largest] < nums[right]) largest = right;
    if(i !== largest) {
      [nums[i], nums[largest]] = [nums[largest], nums[i]];
      i = largest;
    } else {
      break;
    }
  }
}
```

快速排序：

```javascript
var sortArray = function (nums) {
  if (nums.length < 2) return nums;
  const quickSort = (nums, left, right) => {
    if (left >= right) return;
    const random = Math.floor(Math.random() * (right - left + 1)) + left;
    [nums[random], nums[right]] = [nums[right], nums[random]];
    const pivotIndex = partition(nums, left, right);
    quickSort(nums, left, pivotIndex - 1);
    quickSort(nums, pivotIndex + 1, right);
    return nums;
  };
  return quickSort(nums, 0, nums.length - 1);
};

const partition = (nums, left, right) => {
  let pivot = nums[right],
    pivotIndex = left;
  for (let i = left; i < right; ++i) {
    if (nums[i] < pivot) {
      [nums[i], nums[pivotIndex]] = [nums[pivotIndex], nums[i]];
      ++pivotIndex;
    }
  }
  [nums[pivotIndex], nums[right]] = [nums[right], nums[pivotIndex]];
  return pivotIndex;
};
```

以首尾元素为 pivot，在数组为完全逆序的情况下快排时间复杂度为 O(n^2)，因为各次分区操作只排除一个元素，递归深度为 O(n)

原地排序无需处理 `quickSort` 返回值，所有修改均直接作用于 `nums` 数组，当调用 `quickSort(nums, left, pivotIndex - 1)` 时，排序 `nums` 左半部分，当该调用返回时，`nums` 左半部分已经排序，因此当所有递归调用均返回时，`nums` 数组完全排序

冒泡排序：

```javascript
var sortArray = function (nums) {
  const bubbleSort = (nums) => {
    for (let i = 0; i < nums.length - 1; ++i) {
      for (let j = 0; j < nums.length - 1 - i; ++j) {
        if (nums[j] > nums[j + 1])
          [nums[j], nums[j + 1]] = [nums[j + 1], nums[j]];
      }
    }
  };
  bubbleSort(nums);
  return nums;
};
```

归并排序：

```javascript
var sortArray = function (nums) {
  if (nums.length < 2) return nums;
  const mid = Math.floor(nums.length / 2);
  const left = sortArray(nums.slice(0, mid)),
    right = sortArray(nums.slice(mid));
  return merge(left, right);
};

const merge = (left, right) => {
  let i = 0,
    j = 0,
    ans = [];
  while (i < left.length && j < right.length) {
    if (left[i] < right[j]) {
      ans.push(left[i]);
      ++i;
    } else {
      ans.push(right[j]);
      ++j;
    }
  }
  while (i < left.length) {
    ans.push(left[i]);
    ++i;
  }
  while (j < right.length) {
    ans.push(right[j]);
    ++j;
  }
  return ans;
};
```