给定  m x n  的  heights  数组即雪山高度，从任意位置开始，求从雪山滑下去的最长路径  
 * 滑下去的路径必须严格递减  
 * 上下左右滑动  
 * 给定一个体力值，每移动一步消耗一格体力    
 * 传送  k  次即移动至更高的地方  
 * 给定一个  rewards  数组，移动至该位置时获取 bonus 个体力奖励

```js
const getLongestPath = (heights, k, rewards, initialHealth) => {
  const m = heights.length,
    n = heights[0].length;
  const dirs = [
    [-1, 0],
    [0, 1],
    [1, 0],
    [0, -1],
  ];
  let maxLen = 0;
  const dfs = (i, j, remainK, visited, curHealth, len) => {
    if (len > maxLen) maxLen = len;
    if (curHealth <= 0) return;
    for (const dir of dirs) {
      const x = i + dir[0],
        y = j + dir[1];
      if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) continue;
      if (heights[x][y] < heights[i][j]) {
        const newHealth = curHealth - 1 + rewards[x][y];
        visited[x][y] = true;
        dfs(x, y, remainK, visited, newHealth, len + 1);
        visited[x][y] = false;
      } else if (remainK > 0) {
        const newHealth = curHealth - 1 + rewards[x][y];
        visited[x][y] = true;
        dfs(x, y, remainK - 1, visited, newHealth, len + 1);
        visited[x][y] = false;
      }
    }
  };
  for (let i = 0; i < m; ++i) {
    for (let j = 0; j < n; ++j) {
      const visited = new Array(m)
        .fill(false)
        .map(() => new Array(n).fill(false));
      dfs(i, j, k, visited, initialHealth + rewards[i][j], 0);
    }
  }
  return maxLen;
};
```
