1. `useState`：用于管理状态，根据用户交互触发组件的重新渲染，`set` 方法可视为异步的，`setState` 调用不会立即更新状态，React 将新值添加到更新队列，并在 React 的下一个渲染周期中更新状态，保证组件行为的一致性，这种批处理方式可合并多个 `setState`，减少不必要的渲染。`useState` 存储来自父组件 `Props` 时，若父组件 `Props` 变化，子组件 `State` 不会自动更新，因为 `useState` 在组件首次渲染时使用初始值，而后忽略该值，当前 `State` 不变。`useState` 合并了 `constructor`（初始化状态） 和 `componentDidUpdate`（更新状态）。在 `useState` 中以函数作为参数时，该函数不会立即执行，React 只在组件首次渲染时调用该函数，并将其返回值作为初始值即惰性初始化。使用数组解构而非对象解构易于分配多个返回值，我们知道 React Hooks 基于调用顺序的一致性，`useState` 的返回值顺序固定，第一个为状态值，第二个为更新函数，数组解构确保解构时的顺序一致性，此外对象解构通过属性名访问元素，而数组解构通过索引访问元素，无需担心命名冲突
2. `useReducer`：用于管理状态，接收 `reducer` 函数和 `initialState` 值，通过 `dispatch` 触发 `action` 来更新状态，`useReducer` 本身为同步的，而异步逻辑需在 `dispatch` 调用前后执行，此外 `useReducer` 通过将状态更新逻辑集中于一个 `reducer` 函数中以解决闭包陷阱即调用 Hooks 时闭包捕获旧的 `state` 或 `props`，导致副作用函数中的值不是最新的
3. `useContext`：用于访问 `context` 上下文对象，上下文为一种在组件树中传递数据的方式，无需显式在各级组件中传递 `props`。`React.createContext` 创建一个包含 `Provider` 组件和 `Consumer` 组件的上下文对象，在组件树上层通过 `Provider` 组件包裹子组件并传递上下文对象的值 `value`，所有嵌套在 `Provider` 内部的子组件均可通过 `useContext` 访问该上下文对象并订阅其变化，当 `value` 变化时，所有嵌套在 `Provider` 内部的子组件均重新渲染。若上下文对象频繁变化势必触发大量不必要渲染，确保传递给 `Provider` 的 `value` 只在必要时改变，同时将将上下文对象拆分成多个，使用 `React.memo` 对不依赖上下文对象变化的组件进行性能优化
4. `useEffect`：用于处理副作用，接收副作用函数和依赖数组，副作用函数在组件渲染后调用，当依赖项数组发生变化时，React 在重新渲染后调用副作用函数，当无依赖项数组或依赖项数组为空时，React 在每次渲染后调用副作用函数，若副作用函数返回一个函数（不能为异步函数，因为异步函数返回 Promise），其为清理函数，其在副作用函数调用前或组件卸载时调用，`useState` 合并 `componentDidUpdate`（依赖项数组不为空） 和 `componentDidMount` + `componentWillUnmount`（无依赖项数组或依赖项数组为空 + 返回一个 cleanup 函数时）。React 对依赖项数组进行浅比较即比较依赖项数组的引用是否变化，而不是比较依赖项数组之数组或对象的元素或属性，在 `useEffect` 中设置定时器如 `setTimeout` 时，定时器的回调函数在预定时间延迟调用，即便在定时器到期前组件被卸载如切换到另一组件依然如此，除非在组件卸载时清理定时器。在 `useEffect` 中可访问和操作真实 DOM，但无法访问和操作虚拟 DOM，因为 `useEffect` 的副作用执行时机为组件挂载后或组件更新后或组件卸载时，虚拟 DOM 已转化为真实 DOM。若用 `useEffect` 获取到旧值的原因是闭包机制或依赖项数组不含最新数据
5. `useLayoutEffect`：在 React Fiber 架构中，`useEffect` 的回调函数在提交阶段后的空闲时间被调用，`useLayoutEffect` 和 `useEffect` 相似，但用于立即更新 DOM，在所有 DOM 更新后即在页面渲染前调用
6. `useRef`：用于创建 `ref` 以在不触发重新渲染的情况下访问和操作 DOM 元素，持久化存储上一个状态的值，返回的对象有用于访问其值的 `.current` 属性，可随时更新 `current` 属性值而不触发重新渲染，即便将 `useRef` 的 `ref` 添加到 `useEffect` 的依赖项数组中且 `ref` 的 `current` 属性值变化，副作用函数也不调用，因为 React 对依赖项数组进行浅比较，而 `ref` 对象的引用不变。在父组件创建 `ref` 并将其传递给子组件，子组件通过 `forwardRef` 接收父组件传递的 `ref`
7. `forwardRef`：高阶组件，接收父组件传递的属性 `props` 和父组件传递的 `ref`，其用于包裹一个函数组件（起桥梁的作用），使其接收父组件传递的 `ref` 并转发给子组件，再将 `ref` 绑定到其内部某元素或实例上，从而实现父组件直接访问子组件
8. `useImperativeHandle`：用于子组件自定义暴露给父组件的属性和方法，而不直接暴露其 DOM 节点或内部实现，接收父组件传递的 `ref`、`createHandle` 回调函数（其返回一个包含暴露给父组件的属性和方法的对象）和可选的 `dep` 依赖数组（其变化时重新调用 `createHandle`）
9. `useMemo`：用于缓存计算结果如传递给子组件的 `props` 为计算得到的数组或对象，避免在每次渲染时重新计算，其接收回调函数和依赖项数组，返回一个计算结果，只有当依赖项变化时，才重新计算该值
10. `useCallback`：用于缓存回调函数如依赖于父组件的 `props` 之回调传递给子组件时可将其缓存，其接收回调函数和依赖项数组，返回一个回调函数，只有当依赖项变化时，才更新该回调函数
11. `React.memo`：高阶组件，通过浅比较 `props` 决定是否重新渲染组件，若无变化，则不重新渲染组件，`React.memo` 返回一个新组件
12. `useTransition`：React 18 引入的新的调度机制，为 React 并发模式的一部分，用于管理状态更新的优先级，其不接收参数，返回一个数组，包含用于将状态更新标记为过渡的 `startTransition` 函数和用于表示当前是否有过渡中的状态更新之 `isPending` 布尔值。高优先级任务如用户交互必须及时响应，低优先级任务如复杂计算和大量数据渲染等可延迟执行
13. `useDeferedValue`：React 18 引入，用于管理高低优先级任务的状态更新，其接收一个值作为参数，返回一个延迟处理的值
