在函数组件中直接调用子组件中的方法并不像在类组件中那般直接，由于函数组件的特性，我们无法通过 `ref` 直接调用子组件的方法，因为 `ref` 不能直接绑定在函数组件上

1. 回调函数：Props 是父组件传递给子组件的只读数据，子组件无法修改 Props，但子组件可通过接收父组件的回调作为 Props，在合适时调用该回调并将子组件的属性或方法作为参数传递给父组件

```jsx
function ParentComponent() {
  const handleChildData = (data) => console.log("Data from child:", data);
  return <ChildComponent onChildData={handleChildData} />;
}
```

```jsx
function ChildComponent({ onChildData }) {
  const someData = "Some data from ChildComponent";

  const handleClick = () => {
    if (onChildData) onChildData(someData);
  };

  return <button onClick={handleClick}>Click Me</button>;
}
```

2. `useImperativeHandle` & `forwardRef`：`useImperativeHandle` 用于子组件向父组件暴露特定数据，`forwardRef` 用于将 `ref` 从父组件传递给子组件

```jsx
import React, { useRef } from 'react';

function ParentComponent() {
  const childRef = useRef();
  const accessChild = () => {
    if (childRef.current) console.log(childRef.current.someMethod());
  };

  return (
    <>
      <ChildComponent ref={childRef} />
      <button onClick={accessChild}>Access Child Method</button>
    </>
  );
}
```

```jsx
import React, { useImperativeHandle, forwardRef } from 'react';

const ChildComponent = forwardRef((props, ref) => {
  useImperativeHandle(ref, () => ({
    someMethod() {
      return "This data is from child's someMethod";
    },
  }));

  return <div>Child Component</div>;
});
```

3. useContext
4. 全局状态管理库