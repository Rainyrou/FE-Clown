Vapor Mode（Vue3.6 引入，灵感源于 Solid.js） ，核心设计思路是将传统虚拟 DOM 模式的运行时开销提前到编译时消解，通过在编译时执行深度静态分析，将模板直接转换为命令式 DOM 操作代码，完全移除虚拟 DOM 节点创建、Diff 和 Patch 流程，在运行时直接操作真实 DOM，同时为各个动态绑定生成 DOM 更新指令 ​​​（模板编译 → 命令式 DOM 操作 → 真实 DOM），实现从单一的"虚拟 DOM 运行时"架构转换为"虚拟 DOM + Vapor 双运行时"架构，从根本上解决传统虚拟 DOM 模式的性能瓶颈（模板编译 → 渲染函数 → 虚拟 DOM → 真实 DOM）

1. 编译时层：传统虚拟 DOM 模式的问题在于"运行时无法提前感知变化范围，需通过遍历比较定位更新点"，而 Vapor Mode 架构通过编译时遍历模板 AST 以区分静态节点和动态节点，将所有静态节点合并为全局常量片段，运行时一次性插入真实 DOM，避免重复创建静态节点的开销，根据动态节点依赖的响应式数据和执行的 DOM 操作类型生成对应的 DOM 更新指令并批量合并优化，减少运行时 DOM 操作次数
2. 响应式绑定层：从"组件级响应"到"指令级细粒度绑定"，生成动态指令时，通过"响应式追踪标记"将指令与依赖的响应式数据直接绑定，无需运行时动态收集依赖，避免传统响应式的依赖追踪开销，基于  `alien-signals`  响应式引擎为各个动态指令创建独立的 effect 函数，其内部即编译好的 DOM 操作逻辑，当依赖的响应式数据变化时，响应式引擎直接触发对应 effect 函数，无需经过"组件更新 → 虚拟 DOM → Diff → Patch"的冗长链路
3. 运行时层：首次渲染时，将编译时生成的静态 DOM 片段一次性插入到真实 DOM 树，无需逐个节点创建；动态指令仅初始化时绑定，无虚拟 DOM 树的创建过程；处理组件的挂载销毁逻辑，与传统的生命周期兼容；对  `v-on`  绑定的事件采用全局事件委托策略，减少事件监听器数量
