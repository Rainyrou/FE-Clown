> [!todo] To do
> **React 是手动挡，Vue 是自动挡**

**它们都只是同一时代下产品的不同解决方案，仅此而已，它们终将会被时代抛弃（就像俺呜呜）。精通框架没什么屁用，要跳脱出框架本身，否则到死也不知道自己是怎么个死法**

Vue.js 和 React 都是构建用户界面的 JavaScript 库

1. **设计哲学**：

Vue 和 React 的核心理念差异决定了它们的发展轨迹。React 最初就致力于制定 UI 开发的新范式，它要求开发者按照一定规则来编码，当年 Pete Hunt 推广 React 时的一句口号是 "Rethinking Best Practices"，React 敢做这样的尝试，是因为它有 Facebook 的背书，保障它的流行和生态发展。而 Vue 聚焦于降低前端开发的门槛，更多地尊重和适应开发者的习惯，这也是它得以推广的一大因素

2. **Template & JSX**

- Vue 采用基于 HTML 的模板语法，提供数据驱动的视图层框架，允许开发者声明式地将 DOM 绑定到底层 Vue 实例的数据。Vue 更倾向于"万物皆组件"的思想，鼓励开发者使用组件来构建应用程序
* React 采用 JSX，使得在 JavaScript 代码中可以写类似 HTML 的代码，更接近于函数式编程。React 更倾向于"学习一次，随处编写"的思想，它侧重于 UI 组件化，采用单向数据流，通过 State 来控制 UI 的更新。它不提供完整的框架解决方案，而是侧重于构建高效的 UI 层，并鼓励使用不可变数据来推动 UI 的更新

3. **响应式**：

- Vue2  响应式的特点是依赖收集，数据可变，自动派发更新，初始化时通过 `Object.defineProperty`  递归劫持  `data` 所有属性，为其添加 `getter` 和 `setter`。每个组件实例关联一个 `watcher` 实例，在组件渲染时进行依赖收集，并在依赖项的 `setter` 被调用时通知 `watcher` 重新渲染
- Vue3 使用原生 `Proxy`  重构响应式，`Proxy`  修复 Vue2 响应式存在的缺陷，它可以拦截对象的任意操作（包括增删对象属性、数组索引赋值和修改数组长度等），支持更多数据结构，且不再一开始就递归劫持对象属性，而是代理第一层对象本身，运行时才递归，按需代理，用 `effect`  副作用函数来代替 Vue2 的 `watcher`，用 `trackMap`  代替 Vue2 的 `Dep` 统一管理依赖，无需再维护大量依赖关系，性能显著提升
- React  的响应式不是自动的，它基于状态，单向数据流，数据不可变，需要手动 `setState`  来显式触发更新，且当数据改变时会以根组件为目录，默认重新渲染整个组件树，更新粒度更大一些，需要额外使用 `pureComponent` 和 `shouldComponentUpdate` 等防止不必要的渲染，保证整个组件树的渲染完全由其组件的 `props` 决定。若不符合上述情况，此类优化可能导致渲染结果不一致，说白了，React 的组件优化伴随着一定程度的心智负担。React16 之后引入 Fiber 架构，性能显著提升
- 总结：Vue 的响应式数据绑定提供一种更加细粒度的更新机制，而 React 的函数式状态管理则倾向于更可预测的数据流

4. **Diff 算法**：

Diff 算法是 Virtual DOM 的核心，用来比较新旧虚拟 DOM 树中节点的差异，并根据差异对真实 DOM 进行最小量更新

- Vue2 的 Diff 算法采用双指针比较新旧虚拟节点的子节点列表。同层级 vnode 进行比较，如果新的 vnode 存在而旧的不存在，则创建新节点；反之，则删除旧节点。在处理子节点时，使用四个指针（旧前、旧后、新前、新后）进行头尾和尾头的比对（即双端 Diff 算法），尽可能地复用现有节点，避免不必要的 DOM 操作（即快速 Diff 算法）
- Vue3 对 Diff 算法进行了优化，增加了更多的静态标记。在编译阶段，Vue3 能够检测并标记出静态的根节点，这些节点在 Diff 过程中可以被直接跳过。对于动态子节点，Vue3 使用 `Map` 来跟踪节点的索引。Vue3 还引入了最长递增子序列算法（其时间复杂度为O(n log n)）来优化带有 `v-for` 指令的列表渲染，通过计算新旧虚拟节点序列的 LIS，尽可能复用 DOM 元素，并根据差异对真实 DOM 进行最小量更新，因为 LIS 代表无需移动的 DOM 元素集合，只有不在 LIS 中的元素需要移动，这大大减少了布局重排和重新渲染的开销
* React 递归进行同层 vnode 比较，识别差异后将其添加到 `Diff` 队列中，得到一个 patch 树，统一批量操作更新 DOM。如果组件类型或 key 不同，React 直接卸载旧组件并创建新组件。对于列表元素的处理，React 通过比较新旧集合中节点的位置和 `lastIndex` 来判断节点是否需要移动。如果新的 vnode 存在而旧的不存在，则创建新节点；反之，则删除旧节点

5. **总结**

从性能来说，两个框架没有本质差别。硬要说的话，Vue  在更新时在性能优化方面需要的心智负担可能会少一些，而  React  如果不注意，容易导致一些组件无用的  Diff，但实际项目中真正能遇到这种性能瓶颈的情况也是极少数，因此...

(如果公司主 Vue)：总的来说，我觉得 Vue  在性能上更好一些，其有更好的可扩展性、更快的渲染速度和更小的打包体积。从 mixins  到 HOC  到  render props 再到 hooks，React 已基本废弃过去很多基于组件的逻辑抽象模式，抹掉 JSX 相比 Template 的一大优势，现在 Vue3 都能做到，因此我会倾向于 Vue

(如果公司主 React)：总的来说，我觉得在一些小型系统或 H5  端用 Vue 可能会更好一些，不管是上手还是开发都相对容易，而且它有更小的打包体积。但像一些中后台系统，或多人开发的大型项目，React 的函数式编程有着更灵活的结构和可扩展性，生态和解决方案也更多，还可以用 RN 跨端开发，因此我会倾向于 React

