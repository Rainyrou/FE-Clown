Diff 算法是 Virtual DOM 的核心算法，用于高效地比较前后两棵 Virtual DOM 树并计算出最小更新。Vue 2 使用这种算法来高效地更新真实 DOM

以下是 Vue 2 中 Diff 算法的基本原理和执行流程：

1. 在 Vue 中，当组件的状态改变时，新的 Virtual DOM 树是通过渲染函数重新生成的。这个新生成的 Virtual DOM 树与上一次的 Virtual DOM 树可能会有所不同

2. Diff 算法：找出两棵 Virtual DOM 树之间的差异，并计算出一个更新的序列来高效地更新真实 DOM

3. 我们知道，两棵树做 Diff 的时间复杂度是 O(n^3)，因为一棵树的每个节点都要和另一棵树的全部节点比较一次，这就是 n 了，如果找到有变化的节点，执行插入、删除、修改也是 n 的复杂度。所有节点执行一次，再乘以 n，所以是 O(n^3) 的复杂度

因此 Vue2 只做同层的对比，Type 变了就不再对比子节点。只要遍历一遍，对比一下 Type 就行了，这是 O(n) 的时间复杂度，如果 Type 变了就不再对比子节点。另外因为 Virtual DOM 中记录了关联的 DOM 节点，执行 DOM 的增删改也不需要遍历，时间复杂度是 O(1)，整体的 Diff 时间复杂度就是 O(n) 

Vue 2 的 Diff 算法分为两层：`updateChildren` 和 `patchVnode`

- `updateChildren`: 处理父节点的子节点列表之间的差异
- `patchVnode`: 处理单个 VNode 的差异

4. 节点比较

   Vue 2 采用了一种"就地复用"策略，它会尽可能地复用同一位置的旧节点。例如，如果旧的子节点列表为 `[A, B, C, D]`，新的子节点列表为 `[B, A, D, C]`，Vue 将交换 A 和 B，以及 C 和 D，而不是移动它们

   这种策略使 Vue 2 能够在大多数场景下高效工作，但在某些边缘情况下可能不是最优的

5. Key 属性

   Vue 推荐在每个节点上设置一个唯一的 `key` 属性，这可以帮助 Diff 算法更准确、快速地识别节点。有了 `key` 属性，Vue 可以知道哪些节点是新的，哪些是移动过的，哪些是删除的。对于新 vnode 数组的每个节点，我们都要查找在旧 vnode 数组中有没有对应 `key` 的节点 ，有的话就移动到新的位置，没有的话再创建新的节点

6. DOM 更新

   一旦 Diff 算法计算出两棵 Virtual DOM 树之间的差异，Vue 就会根据这些差异来更新真实 DOM。只有真正发生变化的 DOM 元素会被更新，而不是整个 DOM 树

7. Vue 2 中的 Diff 算法有很多优化手段。例如，如果一个元素的整个子树没有变化，那么这个子树将被跳过，而不会进行详细比较
