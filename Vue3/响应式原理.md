##### 底层原理

Vue 3 的响应式原理是通过使用 `Proxy` 对象和副作用函数（effect functions）来实现的

1. **Reactive Data Objects**: 首先，Vue 使用 `Proxy` 对象来对响应式数据进行包装。这允许 Vue 在属性被访问或修改时进行拦截
2. **Tracking Changes**: 当副作用函数首次执行时，它会访问响应式数据的属性，这些访问会触发 `Proxy` 的 `get` 捕获器。在 `get` 捕获器中，副作用函数会被添加到一个依赖集合（通常称为桶）中，这个过程称为追踪（tracking）。每个属性都有自己的依赖集合
3. **Triggering Updates**: 当响应式数据的属性被修改时，`Proxy` 的 `set` 捕获器会被触发。在 `set` 捕获器中，相关联的依赖集合会被检索，且集合中的副作用函数将被执行，这导致组件重新渲染或计算属性重新计算
4. **Effect Stack**: Vue 3 中的副作用函数可以嵌套。为了处理嵌套效应，Vue 维护了一个副作用函数栈，确保当前执行的副作用函数总是正确的
5. **Avoid Infinite Loops**: Vue 3 的响应系统避免了无限循环调用的情况。例如，如果副作用函数更改了它自己正在依赖的响应式数据，这可能会导致它被再次调用，从而造成无限循环。Vue 通过检查是否有副作用函数正在执行来避免这种情况，并确保不会再次调用它
6. **Scheduler Execution**: Vue 3 允许通过调度器控制副作用函数的执行时机和方式。例如，可以使用 `setTimeout` 或 Vue 的 `nextTick` 方法将副作用函数的执行推迟到下一个宏任务或微任务

这些机制结合在一起，使得 Vue 3 的响应式系统非常高效且灵活。对数据变化的跟踪是自动的，只要副作用函数在执行期间访问了响应式数据，Vue 就能知道何时重新执行这些副作用函数以响应数据变化

##### 改进

以下是 Vue 3 的响应式原理与 Vue 2 相比的主要改进：

1. 使用 Proxy 代替 Object.defineProperty

   - 在 Vue 2 中，响应式系统是基于 `Object.defineProperty` 来实现的。这个方法有一些固有限制，如不能检测到对象属性的增删、直接通过索引修改数组或修改数组长度
   - Vue 3 使用 ES6 的 `Proxy` 对象来实现响应式，解决了上述问题。`Proxy` 可以拦截对象的任何操作，包括增删对象属性，还使得整个响应式机制更为灵活和强大，允许 Vue 深入拦截对象的更多行为

2. 性能

   - 由于 Vue 2 使用 `Object.defineProperty`，它需要递归遍历一个对象的所有属性，将它们转换为 getter/setter，这在处理大型对象时可能会导致性能问题
   - 在 Vue 3 中，由于使用 `Proxy`，对象属性只有在第一次被访问时才会被转换为响应式的，这带来了惰性初始化的优势

3. 更好的 TypeScript 支持

   - Vue 2 的响应式系统与 TypeScript 集成存在一定的局限性，TypeScript 没有很好地支持通过 `Object.defineProperty` 增删对象属性
   - Vue 3 的源代码就是用 TypeScript 写的，提供了类型推断，这使得 Vue 3 与 TypeScript 的集成更为紧密

4. 数组问题

   - 在 Vue 2 中，数组的变更检测存在限制，如直接通过索引修改数组或修改数组长度并不是响应式的
   - 在 Vue 3 中，由于使用了 `Proxy`，解决了上述问题

5. 派发更新问题

   - Vue 2 的响应式系统可能导致不必要的组件重新渲染，因为它总是在父子组件之间"派发更新"
   - Vue 3 的依赖追踪系统更加精确，只有真正依赖某个状态的组件才会重新渲染，能显著减少不必要的渲染和虚拟 DOM 对比，进一步提高性能

6. reactive & ref

- `reactive` 是一个方法，用于创建一个响应式对象。与 Vue 2 的 `Vue.observable()` 方法相似，但提供了更强大的功能
- 当你解构或传递响应式对象的属性时，这些属性仍然是响应式的。这与 Vue 2 不同，解构后的属性可能会失去其响应性

```JavaScript
const obj = reactive({ count: 0 });
obj.count++; // Vue 3 响应式系统会跟踪此更改
```

- `ref` 用于创建一个响应式引用。其返回的对象有一个名为 `value` 的属性，这个属性指向传递给 `ref` 的原始值
- `ref` 特别适用于跟踪基本数据类型的变化，因为基本数据类型本身不是对象，不能被直接转化为响应式
- 在 Vue 3 的模板或 `setup` 函数中，你不需要每次都通过 `.value` 访问 `ref` 的值，Vue 自动为你解开引用

```JavaScript
const count = ref(0);
count.value++; // Vue 3 响应式系统会跟踪此更改
```


